// Code generated by counterfeiter. DO NOT EDIT.
package servicefakes

import (
	"context"
	"sync"

	"github.com/ostenbom/refunction/cri/service"
	"google.golang.org/grpc"
	"k8s.io/cri-api/pkg/apis/runtime/v1alpha2"
)

type FakeContainerdCRIService struct {
	AttachStub        func(context.Context, *v1alpha2.AttachRequest) (*v1alpha2.AttachResponse, error)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.AttachRequest
	}
	attachReturns struct {
		result1 *v1alpha2.AttachResponse
		result2 error
	}
	attachReturnsOnCall map[int]struct {
		result1 *v1alpha2.AttachResponse
		result2 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStatsStub        func(context.Context, *v1alpha2.ContainerStatsRequest) (*v1alpha2.ContainerStatsResponse, error)
	containerStatsMutex       sync.RWMutex
	containerStatsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ContainerStatsRequest
	}
	containerStatsReturns struct {
		result1 *v1alpha2.ContainerStatsResponse
		result2 error
	}
	containerStatsReturnsOnCall map[int]struct {
		result1 *v1alpha2.ContainerStatsResponse
		result2 error
	}
	ContainerStatusStub        func(context.Context, *v1alpha2.ContainerStatusRequest) (*v1alpha2.ContainerStatusResponse, error)
	containerStatusMutex       sync.RWMutex
	containerStatusArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ContainerStatusRequest
	}
	containerStatusReturns struct {
		result1 *v1alpha2.ContainerStatusResponse
		result2 error
	}
	containerStatusReturnsOnCall map[int]struct {
		result1 *v1alpha2.ContainerStatusResponse
		result2 error
	}
	CreateContainerStub        func(context.Context, *v1alpha2.CreateContainerRequest) (*v1alpha2.CreateContainerResponse, error)
	createContainerMutex       sync.RWMutex
	createContainerArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.CreateContainerRequest
	}
	createContainerReturns struct {
		result1 *v1alpha2.CreateContainerResponse
		result2 error
	}
	createContainerReturnsOnCall map[int]struct {
		result1 *v1alpha2.CreateContainerResponse
		result2 error
	}
	ExecStub        func(context.Context, *v1alpha2.ExecRequest) (*v1alpha2.ExecResponse, error)
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ExecRequest
	}
	execReturns struct {
		result1 *v1alpha2.ExecResponse
		result2 error
	}
	execReturnsOnCall map[int]struct {
		result1 *v1alpha2.ExecResponse
		result2 error
	}
	ExecSyncStub        func(context.Context, *v1alpha2.ExecSyncRequest) (*v1alpha2.ExecSyncResponse, error)
	execSyncMutex       sync.RWMutex
	execSyncArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ExecSyncRequest
	}
	execSyncReturns struct {
		result1 *v1alpha2.ExecSyncResponse
		result2 error
	}
	execSyncReturnsOnCall map[int]struct {
		result1 *v1alpha2.ExecSyncResponse
		result2 error
	}
	ImageFsInfoStub        func(context.Context, *v1alpha2.ImageFsInfoRequest) (*v1alpha2.ImageFsInfoResponse, error)
	imageFsInfoMutex       sync.RWMutex
	imageFsInfoArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ImageFsInfoRequest
	}
	imageFsInfoReturns struct {
		result1 *v1alpha2.ImageFsInfoResponse
		result2 error
	}
	imageFsInfoReturnsOnCall map[int]struct {
		result1 *v1alpha2.ImageFsInfoResponse
		result2 error
	}
	ImageStatusStub        func(context.Context, *v1alpha2.ImageStatusRequest) (*v1alpha2.ImageStatusResponse, error)
	imageStatusMutex       sync.RWMutex
	imageStatusArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ImageStatusRequest
	}
	imageStatusReturns struct {
		result1 *v1alpha2.ImageStatusResponse
		result2 error
	}
	imageStatusReturnsOnCall map[int]struct {
		result1 *v1alpha2.ImageStatusResponse
		result2 error
	}
	ListContainerStatsStub        func(context.Context, *v1alpha2.ListContainerStatsRequest) (*v1alpha2.ListContainerStatsResponse, error)
	listContainerStatsMutex       sync.RWMutex
	listContainerStatsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ListContainerStatsRequest
	}
	listContainerStatsReturns struct {
		result1 *v1alpha2.ListContainerStatsResponse
		result2 error
	}
	listContainerStatsReturnsOnCall map[int]struct {
		result1 *v1alpha2.ListContainerStatsResponse
		result2 error
	}
	ListContainersStub        func(context.Context, *v1alpha2.ListContainersRequest) (*v1alpha2.ListContainersResponse, error)
	listContainersMutex       sync.RWMutex
	listContainersArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ListContainersRequest
	}
	listContainersReturns struct {
		result1 *v1alpha2.ListContainersResponse
		result2 error
	}
	listContainersReturnsOnCall map[int]struct {
		result1 *v1alpha2.ListContainersResponse
		result2 error
	}
	ListImagesStub        func(context.Context, *v1alpha2.ListImagesRequest) (*v1alpha2.ListImagesResponse, error)
	listImagesMutex       sync.RWMutex
	listImagesArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ListImagesRequest
	}
	listImagesReturns struct {
		result1 *v1alpha2.ListImagesResponse
		result2 error
	}
	listImagesReturnsOnCall map[int]struct {
		result1 *v1alpha2.ListImagesResponse
		result2 error
	}
	ListPodSandboxStub        func(context.Context, *v1alpha2.ListPodSandboxRequest) (*v1alpha2.ListPodSandboxResponse, error)
	listPodSandboxMutex       sync.RWMutex
	listPodSandboxArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ListPodSandboxRequest
	}
	listPodSandboxReturns struct {
		result1 *v1alpha2.ListPodSandboxResponse
		result2 error
	}
	listPodSandboxReturnsOnCall map[int]struct {
		result1 *v1alpha2.ListPodSandboxResponse
		result2 error
	}
	PodSandboxStatusStub        func(context.Context, *v1alpha2.PodSandboxStatusRequest) (*v1alpha2.PodSandboxStatusResponse, error)
	podSandboxStatusMutex       sync.RWMutex
	podSandboxStatusArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.PodSandboxStatusRequest
	}
	podSandboxStatusReturns struct {
		result1 *v1alpha2.PodSandboxStatusResponse
		result2 error
	}
	podSandboxStatusReturnsOnCall map[int]struct {
		result1 *v1alpha2.PodSandboxStatusResponse
		result2 error
	}
	PortForwardStub        func(context.Context, *v1alpha2.PortForwardRequest) (*v1alpha2.PortForwardResponse, error)
	portForwardMutex       sync.RWMutex
	portForwardArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.PortForwardRequest
	}
	portForwardReturns struct {
		result1 *v1alpha2.PortForwardResponse
		result2 error
	}
	portForwardReturnsOnCall map[int]struct {
		result1 *v1alpha2.PortForwardResponse
		result2 error
	}
	PullImageStub        func(context.Context, *v1alpha2.PullImageRequest) (*v1alpha2.PullImageResponse, error)
	pullImageMutex       sync.RWMutex
	pullImageArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.PullImageRequest
	}
	pullImageReturns struct {
		result1 *v1alpha2.PullImageResponse
		result2 error
	}
	pullImageReturnsOnCall map[int]struct {
		result1 *v1alpha2.PullImageResponse
		result2 error
	}
	RegisterStub        func(*grpc.Server) error
	registerMutex       sync.RWMutex
	registerArgsForCall []struct {
		arg1 *grpc.Server
	}
	registerReturns struct {
		result1 error
	}
	registerReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveContainerStub        func(context.Context, *v1alpha2.RemoveContainerRequest) (*v1alpha2.RemoveContainerResponse, error)
	removeContainerMutex       sync.RWMutex
	removeContainerArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.RemoveContainerRequest
	}
	removeContainerReturns struct {
		result1 *v1alpha2.RemoveContainerResponse
		result2 error
	}
	removeContainerReturnsOnCall map[int]struct {
		result1 *v1alpha2.RemoveContainerResponse
		result2 error
	}
	RemoveImageStub        func(context.Context, *v1alpha2.RemoveImageRequest) (*v1alpha2.RemoveImageResponse, error)
	removeImageMutex       sync.RWMutex
	removeImageArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.RemoveImageRequest
	}
	removeImageReturns struct {
		result1 *v1alpha2.RemoveImageResponse
		result2 error
	}
	removeImageReturnsOnCall map[int]struct {
		result1 *v1alpha2.RemoveImageResponse
		result2 error
	}
	RemovePodSandboxStub        func(context.Context, *v1alpha2.RemovePodSandboxRequest) (*v1alpha2.RemovePodSandboxResponse, error)
	removePodSandboxMutex       sync.RWMutex
	removePodSandboxArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.RemovePodSandboxRequest
	}
	removePodSandboxReturns struct {
		result1 *v1alpha2.RemovePodSandboxResponse
		result2 error
	}
	removePodSandboxReturnsOnCall map[int]struct {
		result1 *v1alpha2.RemovePodSandboxResponse
		result2 error
	}
	ReopenContainerLogStub        func(context.Context, *v1alpha2.ReopenContainerLogRequest) (*v1alpha2.ReopenContainerLogResponse, error)
	reopenContainerLogMutex       sync.RWMutex
	reopenContainerLogArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.ReopenContainerLogRequest
	}
	reopenContainerLogReturns struct {
		result1 *v1alpha2.ReopenContainerLogResponse
		result2 error
	}
	reopenContainerLogReturnsOnCall map[int]struct {
		result1 *v1alpha2.ReopenContainerLogResponse
		result2 error
	}
	RunStub        func() error
	runMutex       sync.RWMutex
	runArgsForCall []struct {
	}
	runReturns struct {
		result1 error
	}
	runReturnsOnCall map[int]struct {
		result1 error
	}
	RunPodSandboxStub        func(context.Context, *v1alpha2.RunPodSandboxRequest) (*v1alpha2.RunPodSandboxResponse, error)
	runPodSandboxMutex       sync.RWMutex
	runPodSandboxArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.RunPodSandboxRequest
	}
	runPodSandboxReturns struct {
		result1 *v1alpha2.RunPodSandboxResponse
		result2 error
	}
	runPodSandboxReturnsOnCall map[int]struct {
		result1 *v1alpha2.RunPodSandboxResponse
		result2 error
	}
	StartContainerStub        func(context.Context, *v1alpha2.StartContainerRequest) (*v1alpha2.StartContainerResponse, error)
	startContainerMutex       sync.RWMutex
	startContainerArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.StartContainerRequest
	}
	startContainerReturns struct {
		result1 *v1alpha2.StartContainerResponse
		result2 error
	}
	startContainerReturnsOnCall map[int]struct {
		result1 *v1alpha2.StartContainerResponse
		result2 error
	}
	StatusStub        func(context.Context, *v1alpha2.StatusRequest) (*v1alpha2.StatusResponse, error)
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.StatusRequest
	}
	statusReturns struct {
		result1 *v1alpha2.StatusResponse
		result2 error
	}
	statusReturnsOnCall map[int]struct {
		result1 *v1alpha2.StatusResponse
		result2 error
	}
	StopContainerStub        func(context.Context, *v1alpha2.StopContainerRequest) (*v1alpha2.StopContainerResponse, error)
	stopContainerMutex       sync.RWMutex
	stopContainerArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.StopContainerRequest
	}
	stopContainerReturns struct {
		result1 *v1alpha2.StopContainerResponse
		result2 error
	}
	stopContainerReturnsOnCall map[int]struct {
		result1 *v1alpha2.StopContainerResponse
		result2 error
	}
	StopPodSandboxStub        func(context.Context, *v1alpha2.StopPodSandboxRequest) (*v1alpha2.StopPodSandboxResponse, error)
	stopPodSandboxMutex       sync.RWMutex
	stopPodSandboxArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.StopPodSandboxRequest
	}
	stopPodSandboxReturns struct {
		result1 *v1alpha2.StopPodSandboxResponse
		result2 error
	}
	stopPodSandboxReturnsOnCall map[int]struct {
		result1 *v1alpha2.StopPodSandboxResponse
		result2 error
	}
	UpdateContainerResourcesStub        func(context.Context, *v1alpha2.UpdateContainerResourcesRequest) (*v1alpha2.UpdateContainerResourcesResponse, error)
	updateContainerResourcesMutex       sync.RWMutex
	updateContainerResourcesArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.UpdateContainerResourcesRequest
	}
	updateContainerResourcesReturns struct {
		result1 *v1alpha2.UpdateContainerResourcesResponse
		result2 error
	}
	updateContainerResourcesReturnsOnCall map[int]struct {
		result1 *v1alpha2.UpdateContainerResourcesResponse
		result2 error
	}
	UpdateRuntimeConfigStub        func(context.Context, *v1alpha2.UpdateRuntimeConfigRequest) (*v1alpha2.UpdateRuntimeConfigResponse, error)
	updateRuntimeConfigMutex       sync.RWMutex
	updateRuntimeConfigArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.UpdateRuntimeConfigRequest
	}
	updateRuntimeConfigReturns struct {
		result1 *v1alpha2.UpdateRuntimeConfigResponse
		result2 error
	}
	updateRuntimeConfigReturnsOnCall map[int]struct {
		result1 *v1alpha2.UpdateRuntimeConfigResponse
		result2 error
	}
	VersionStub        func(context.Context, *v1alpha2.VersionRequest) (*v1alpha2.VersionResponse, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha2.VersionRequest
	}
	versionReturns struct {
		result1 *v1alpha2.VersionResponse
		result2 error
	}
	versionReturnsOnCall map[int]struct {
		result1 *v1alpha2.VersionResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainerdCRIService) Attach(arg1 context.Context, arg2 *v1alpha2.AttachRequest) (*v1alpha2.AttachResponse, error) {
	fake.attachMutex.Lock()
	ret, specificReturn := fake.attachReturnsOnCall[len(fake.attachArgsForCall)]
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.AttachRequest
	}{arg1, arg2})
	fake.recordInvocation("Attach", []interface{}{arg1, arg2})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.attachReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeContainerdCRIService) AttachCalls(stub func(context.Context, *v1alpha2.AttachRequest) (*v1alpha2.AttachResponse, error)) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = stub
}

func (fake *FakeContainerdCRIService) AttachArgsForCall(i int) (context.Context, *v1alpha2.AttachRequest) {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	argsForCall := fake.attachArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) AttachReturns(result1 *v1alpha2.AttachResponse, result2 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 *v1alpha2.AttachResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) AttachReturnsOnCall(i int, result1 *v1alpha2.AttachResponse, result2 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	if fake.attachReturnsOnCall == nil {
		fake.attachReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.AttachResponse
			result2 error
		})
	}
	fake.attachReturnsOnCall[i] = struct {
		result1 *v1alpha2.AttachResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *FakeContainerdCRIService) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeContainerdCRIService) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeContainerdCRIService) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerdCRIService) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerdCRIService) ContainerStats(arg1 context.Context, arg2 *v1alpha2.ContainerStatsRequest) (*v1alpha2.ContainerStatsResponse, error) {
	fake.containerStatsMutex.Lock()
	ret, specificReturn := fake.containerStatsReturnsOnCall[len(fake.containerStatsArgsForCall)]
	fake.containerStatsArgsForCall = append(fake.containerStatsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ContainerStatsRequest
	}{arg1, arg2})
	fake.recordInvocation("ContainerStats", []interface{}{arg1, arg2})
	fake.containerStatsMutex.Unlock()
	if fake.ContainerStatsStub != nil {
		return fake.ContainerStatsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerStatsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ContainerStatsCallCount() int {
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	return len(fake.containerStatsArgsForCall)
}

func (fake *FakeContainerdCRIService) ContainerStatsCalls(stub func(context.Context, *v1alpha2.ContainerStatsRequest) (*v1alpha2.ContainerStatsResponse, error)) {
	fake.containerStatsMutex.Lock()
	defer fake.containerStatsMutex.Unlock()
	fake.ContainerStatsStub = stub
}

func (fake *FakeContainerdCRIService) ContainerStatsArgsForCall(i int) (context.Context, *v1alpha2.ContainerStatsRequest) {
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	argsForCall := fake.containerStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ContainerStatsReturns(result1 *v1alpha2.ContainerStatsResponse, result2 error) {
	fake.containerStatsMutex.Lock()
	defer fake.containerStatsMutex.Unlock()
	fake.ContainerStatsStub = nil
	fake.containerStatsReturns = struct {
		result1 *v1alpha2.ContainerStatsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ContainerStatsReturnsOnCall(i int, result1 *v1alpha2.ContainerStatsResponse, result2 error) {
	fake.containerStatsMutex.Lock()
	defer fake.containerStatsMutex.Unlock()
	fake.ContainerStatsStub = nil
	if fake.containerStatsReturnsOnCall == nil {
		fake.containerStatsReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ContainerStatsResponse
			result2 error
		})
	}
	fake.containerStatsReturnsOnCall[i] = struct {
		result1 *v1alpha2.ContainerStatsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ContainerStatus(arg1 context.Context, arg2 *v1alpha2.ContainerStatusRequest) (*v1alpha2.ContainerStatusResponse, error) {
	fake.containerStatusMutex.Lock()
	ret, specificReturn := fake.containerStatusReturnsOnCall[len(fake.containerStatusArgsForCall)]
	fake.containerStatusArgsForCall = append(fake.containerStatusArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ContainerStatusRequest
	}{arg1, arg2})
	fake.recordInvocation("ContainerStatus", []interface{}{arg1, arg2})
	fake.containerStatusMutex.Unlock()
	if fake.ContainerStatusStub != nil {
		return fake.ContainerStatusStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ContainerStatusCallCount() int {
	fake.containerStatusMutex.RLock()
	defer fake.containerStatusMutex.RUnlock()
	return len(fake.containerStatusArgsForCall)
}

func (fake *FakeContainerdCRIService) ContainerStatusCalls(stub func(context.Context, *v1alpha2.ContainerStatusRequest) (*v1alpha2.ContainerStatusResponse, error)) {
	fake.containerStatusMutex.Lock()
	defer fake.containerStatusMutex.Unlock()
	fake.ContainerStatusStub = stub
}

func (fake *FakeContainerdCRIService) ContainerStatusArgsForCall(i int) (context.Context, *v1alpha2.ContainerStatusRequest) {
	fake.containerStatusMutex.RLock()
	defer fake.containerStatusMutex.RUnlock()
	argsForCall := fake.containerStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ContainerStatusReturns(result1 *v1alpha2.ContainerStatusResponse, result2 error) {
	fake.containerStatusMutex.Lock()
	defer fake.containerStatusMutex.Unlock()
	fake.ContainerStatusStub = nil
	fake.containerStatusReturns = struct {
		result1 *v1alpha2.ContainerStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ContainerStatusReturnsOnCall(i int, result1 *v1alpha2.ContainerStatusResponse, result2 error) {
	fake.containerStatusMutex.Lock()
	defer fake.containerStatusMutex.Unlock()
	fake.ContainerStatusStub = nil
	if fake.containerStatusReturnsOnCall == nil {
		fake.containerStatusReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ContainerStatusResponse
			result2 error
		})
	}
	fake.containerStatusReturnsOnCall[i] = struct {
		result1 *v1alpha2.ContainerStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) CreateContainer(arg1 context.Context, arg2 *v1alpha2.CreateContainerRequest) (*v1alpha2.CreateContainerResponse, error) {
	fake.createContainerMutex.Lock()
	ret, specificReturn := fake.createContainerReturnsOnCall[len(fake.createContainerArgsForCall)]
	fake.createContainerArgsForCall = append(fake.createContainerArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.CreateContainerRequest
	}{arg1, arg2})
	fake.recordInvocation("CreateContainer", []interface{}{arg1, arg2})
	fake.createContainerMutex.Unlock()
	if fake.CreateContainerStub != nil {
		return fake.CreateContainerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) CreateContainerCallCount() int {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return len(fake.createContainerArgsForCall)
}

func (fake *FakeContainerdCRIService) CreateContainerCalls(stub func(context.Context, *v1alpha2.CreateContainerRequest) (*v1alpha2.CreateContainerResponse, error)) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = stub
}

func (fake *FakeContainerdCRIService) CreateContainerArgsForCall(i int) (context.Context, *v1alpha2.CreateContainerRequest) {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	argsForCall := fake.createContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) CreateContainerReturns(result1 *v1alpha2.CreateContainerResponse, result2 error) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = nil
	fake.createContainerReturns = struct {
		result1 *v1alpha2.CreateContainerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) CreateContainerReturnsOnCall(i int, result1 *v1alpha2.CreateContainerResponse, result2 error) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = nil
	if fake.createContainerReturnsOnCall == nil {
		fake.createContainerReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.CreateContainerResponse
			result2 error
		})
	}
	fake.createContainerReturnsOnCall[i] = struct {
		result1 *v1alpha2.CreateContainerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) Exec(arg1 context.Context, arg2 *v1alpha2.ExecRequest) (*v1alpha2.ExecResponse, error) {
	fake.execMutex.Lock()
	ret, specificReturn := fake.execReturnsOnCall[len(fake.execArgsForCall)]
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ExecRequest
	}{arg1, arg2})
	fake.recordInvocation("Exec", []interface{}{arg1, arg2})
	fake.execMutex.Unlock()
	if fake.ExecStub != nil {
		return fake.ExecStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.execReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *FakeContainerdCRIService) ExecCalls(stub func(context.Context, *v1alpha2.ExecRequest) (*v1alpha2.ExecResponse, error)) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = stub
}

func (fake *FakeContainerdCRIService) ExecArgsForCall(i int) (context.Context, *v1alpha2.ExecRequest) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	argsForCall := fake.execArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ExecReturns(result1 *v1alpha2.ExecResponse, result2 error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 *v1alpha2.ExecResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ExecReturnsOnCall(i int, result1 *v1alpha2.ExecResponse, result2 error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = nil
	if fake.execReturnsOnCall == nil {
		fake.execReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ExecResponse
			result2 error
		})
	}
	fake.execReturnsOnCall[i] = struct {
		result1 *v1alpha2.ExecResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ExecSync(arg1 context.Context, arg2 *v1alpha2.ExecSyncRequest) (*v1alpha2.ExecSyncResponse, error) {
	fake.execSyncMutex.Lock()
	ret, specificReturn := fake.execSyncReturnsOnCall[len(fake.execSyncArgsForCall)]
	fake.execSyncArgsForCall = append(fake.execSyncArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ExecSyncRequest
	}{arg1, arg2})
	fake.recordInvocation("ExecSync", []interface{}{arg1, arg2})
	fake.execSyncMutex.Unlock()
	if fake.ExecSyncStub != nil {
		return fake.ExecSyncStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.execSyncReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ExecSyncCallCount() int {
	fake.execSyncMutex.RLock()
	defer fake.execSyncMutex.RUnlock()
	return len(fake.execSyncArgsForCall)
}

func (fake *FakeContainerdCRIService) ExecSyncCalls(stub func(context.Context, *v1alpha2.ExecSyncRequest) (*v1alpha2.ExecSyncResponse, error)) {
	fake.execSyncMutex.Lock()
	defer fake.execSyncMutex.Unlock()
	fake.ExecSyncStub = stub
}

func (fake *FakeContainerdCRIService) ExecSyncArgsForCall(i int) (context.Context, *v1alpha2.ExecSyncRequest) {
	fake.execSyncMutex.RLock()
	defer fake.execSyncMutex.RUnlock()
	argsForCall := fake.execSyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ExecSyncReturns(result1 *v1alpha2.ExecSyncResponse, result2 error) {
	fake.execSyncMutex.Lock()
	defer fake.execSyncMutex.Unlock()
	fake.ExecSyncStub = nil
	fake.execSyncReturns = struct {
		result1 *v1alpha2.ExecSyncResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ExecSyncReturnsOnCall(i int, result1 *v1alpha2.ExecSyncResponse, result2 error) {
	fake.execSyncMutex.Lock()
	defer fake.execSyncMutex.Unlock()
	fake.ExecSyncStub = nil
	if fake.execSyncReturnsOnCall == nil {
		fake.execSyncReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ExecSyncResponse
			result2 error
		})
	}
	fake.execSyncReturnsOnCall[i] = struct {
		result1 *v1alpha2.ExecSyncResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ImageFsInfo(arg1 context.Context, arg2 *v1alpha2.ImageFsInfoRequest) (*v1alpha2.ImageFsInfoResponse, error) {
	fake.imageFsInfoMutex.Lock()
	ret, specificReturn := fake.imageFsInfoReturnsOnCall[len(fake.imageFsInfoArgsForCall)]
	fake.imageFsInfoArgsForCall = append(fake.imageFsInfoArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ImageFsInfoRequest
	}{arg1, arg2})
	fake.recordInvocation("ImageFsInfo", []interface{}{arg1, arg2})
	fake.imageFsInfoMutex.Unlock()
	if fake.ImageFsInfoStub != nil {
		return fake.ImageFsInfoStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageFsInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ImageFsInfoCallCount() int {
	fake.imageFsInfoMutex.RLock()
	defer fake.imageFsInfoMutex.RUnlock()
	return len(fake.imageFsInfoArgsForCall)
}

func (fake *FakeContainerdCRIService) ImageFsInfoCalls(stub func(context.Context, *v1alpha2.ImageFsInfoRequest) (*v1alpha2.ImageFsInfoResponse, error)) {
	fake.imageFsInfoMutex.Lock()
	defer fake.imageFsInfoMutex.Unlock()
	fake.ImageFsInfoStub = stub
}

func (fake *FakeContainerdCRIService) ImageFsInfoArgsForCall(i int) (context.Context, *v1alpha2.ImageFsInfoRequest) {
	fake.imageFsInfoMutex.RLock()
	defer fake.imageFsInfoMutex.RUnlock()
	argsForCall := fake.imageFsInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ImageFsInfoReturns(result1 *v1alpha2.ImageFsInfoResponse, result2 error) {
	fake.imageFsInfoMutex.Lock()
	defer fake.imageFsInfoMutex.Unlock()
	fake.ImageFsInfoStub = nil
	fake.imageFsInfoReturns = struct {
		result1 *v1alpha2.ImageFsInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ImageFsInfoReturnsOnCall(i int, result1 *v1alpha2.ImageFsInfoResponse, result2 error) {
	fake.imageFsInfoMutex.Lock()
	defer fake.imageFsInfoMutex.Unlock()
	fake.ImageFsInfoStub = nil
	if fake.imageFsInfoReturnsOnCall == nil {
		fake.imageFsInfoReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ImageFsInfoResponse
			result2 error
		})
	}
	fake.imageFsInfoReturnsOnCall[i] = struct {
		result1 *v1alpha2.ImageFsInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ImageStatus(arg1 context.Context, arg2 *v1alpha2.ImageStatusRequest) (*v1alpha2.ImageStatusResponse, error) {
	fake.imageStatusMutex.Lock()
	ret, specificReturn := fake.imageStatusReturnsOnCall[len(fake.imageStatusArgsForCall)]
	fake.imageStatusArgsForCall = append(fake.imageStatusArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ImageStatusRequest
	}{arg1, arg2})
	fake.recordInvocation("ImageStatus", []interface{}{arg1, arg2})
	fake.imageStatusMutex.Unlock()
	if fake.ImageStatusStub != nil {
		return fake.ImageStatusStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ImageStatusCallCount() int {
	fake.imageStatusMutex.RLock()
	defer fake.imageStatusMutex.RUnlock()
	return len(fake.imageStatusArgsForCall)
}

func (fake *FakeContainerdCRIService) ImageStatusCalls(stub func(context.Context, *v1alpha2.ImageStatusRequest) (*v1alpha2.ImageStatusResponse, error)) {
	fake.imageStatusMutex.Lock()
	defer fake.imageStatusMutex.Unlock()
	fake.ImageStatusStub = stub
}

func (fake *FakeContainerdCRIService) ImageStatusArgsForCall(i int) (context.Context, *v1alpha2.ImageStatusRequest) {
	fake.imageStatusMutex.RLock()
	defer fake.imageStatusMutex.RUnlock()
	argsForCall := fake.imageStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ImageStatusReturns(result1 *v1alpha2.ImageStatusResponse, result2 error) {
	fake.imageStatusMutex.Lock()
	defer fake.imageStatusMutex.Unlock()
	fake.ImageStatusStub = nil
	fake.imageStatusReturns = struct {
		result1 *v1alpha2.ImageStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ImageStatusReturnsOnCall(i int, result1 *v1alpha2.ImageStatusResponse, result2 error) {
	fake.imageStatusMutex.Lock()
	defer fake.imageStatusMutex.Unlock()
	fake.ImageStatusStub = nil
	if fake.imageStatusReturnsOnCall == nil {
		fake.imageStatusReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ImageStatusResponse
			result2 error
		})
	}
	fake.imageStatusReturnsOnCall[i] = struct {
		result1 *v1alpha2.ImageStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ListContainerStats(arg1 context.Context, arg2 *v1alpha2.ListContainerStatsRequest) (*v1alpha2.ListContainerStatsResponse, error) {
	fake.listContainerStatsMutex.Lock()
	ret, specificReturn := fake.listContainerStatsReturnsOnCall[len(fake.listContainerStatsArgsForCall)]
	fake.listContainerStatsArgsForCall = append(fake.listContainerStatsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ListContainerStatsRequest
	}{arg1, arg2})
	fake.recordInvocation("ListContainerStats", []interface{}{arg1, arg2})
	fake.listContainerStatsMutex.Unlock()
	if fake.ListContainerStatsStub != nil {
		return fake.ListContainerStatsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listContainerStatsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ListContainerStatsCallCount() int {
	fake.listContainerStatsMutex.RLock()
	defer fake.listContainerStatsMutex.RUnlock()
	return len(fake.listContainerStatsArgsForCall)
}

func (fake *FakeContainerdCRIService) ListContainerStatsCalls(stub func(context.Context, *v1alpha2.ListContainerStatsRequest) (*v1alpha2.ListContainerStatsResponse, error)) {
	fake.listContainerStatsMutex.Lock()
	defer fake.listContainerStatsMutex.Unlock()
	fake.ListContainerStatsStub = stub
}

func (fake *FakeContainerdCRIService) ListContainerStatsArgsForCall(i int) (context.Context, *v1alpha2.ListContainerStatsRequest) {
	fake.listContainerStatsMutex.RLock()
	defer fake.listContainerStatsMutex.RUnlock()
	argsForCall := fake.listContainerStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ListContainerStatsReturns(result1 *v1alpha2.ListContainerStatsResponse, result2 error) {
	fake.listContainerStatsMutex.Lock()
	defer fake.listContainerStatsMutex.Unlock()
	fake.ListContainerStatsStub = nil
	fake.listContainerStatsReturns = struct {
		result1 *v1alpha2.ListContainerStatsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ListContainerStatsReturnsOnCall(i int, result1 *v1alpha2.ListContainerStatsResponse, result2 error) {
	fake.listContainerStatsMutex.Lock()
	defer fake.listContainerStatsMutex.Unlock()
	fake.ListContainerStatsStub = nil
	if fake.listContainerStatsReturnsOnCall == nil {
		fake.listContainerStatsReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ListContainerStatsResponse
			result2 error
		})
	}
	fake.listContainerStatsReturnsOnCall[i] = struct {
		result1 *v1alpha2.ListContainerStatsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ListContainers(arg1 context.Context, arg2 *v1alpha2.ListContainersRequest) (*v1alpha2.ListContainersResponse, error) {
	fake.listContainersMutex.Lock()
	ret, specificReturn := fake.listContainersReturnsOnCall[len(fake.listContainersArgsForCall)]
	fake.listContainersArgsForCall = append(fake.listContainersArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ListContainersRequest
	}{arg1, arg2})
	fake.recordInvocation("ListContainers", []interface{}{arg1, arg2})
	fake.listContainersMutex.Unlock()
	if fake.ListContainersStub != nil {
		return fake.ListContainersStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ListContainersCallCount() int {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	return len(fake.listContainersArgsForCall)
}

func (fake *FakeContainerdCRIService) ListContainersCalls(stub func(context.Context, *v1alpha2.ListContainersRequest) (*v1alpha2.ListContainersResponse, error)) {
	fake.listContainersMutex.Lock()
	defer fake.listContainersMutex.Unlock()
	fake.ListContainersStub = stub
}

func (fake *FakeContainerdCRIService) ListContainersArgsForCall(i int) (context.Context, *v1alpha2.ListContainersRequest) {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	argsForCall := fake.listContainersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ListContainersReturns(result1 *v1alpha2.ListContainersResponse, result2 error) {
	fake.listContainersMutex.Lock()
	defer fake.listContainersMutex.Unlock()
	fake.ListContainersStub = nil
	fake.listContainersReturns = struct {
		result1 *v1alpha2.ListContainersResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ListContainersReturnsOnCall(i int, result1 *v1alpha2.ListContainersResponse, result2 error) {
	fake.listContainersMutex.Lock()
	defer fake.listContainersMutex.Unlock()
	fake.ListContainersStub = nil
	if fake.listContainersReturnsOnCall == nil {
		fake.listContainersReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ListContainersResponse
			result2 error
		})
	}
	fake.listContainersReturnsOnCall[i] = struct {
		result1 *v1alpha2.ListContainersResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ListImages(arg1 context.Context, arg2 *v1alpha2.ListImagesRequest) (*v1alpha2.ListImagesResponse, error) {
	fake.listImagesMutex.Lock()
	ret, specificReturn := fake.listImagesReturnsOnCall[len(fake.listImagesArgsForCall)]
	fake.listImagesArgsForCall = append(fake.listImagesArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ListImagesRequest
	}{arg1, arg2})
	fake.recordInvocation("ListImages", []interface{}{arg1, arg2})
	fake.listImagesMutex.Unlock()
	if fake.ListImagesStub != nil {
		return fake.ListImagesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listImagesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ListImagesCallCount() int {
	fake.listImagesMutex.RLock()
	defer fake.listImagesMutex.RUnlock()
	return len(fake.listImagesArgsForCall)
}

func (fake *FakeContainerdCRIService) ListImagesCalls(stub func(context.Context, *v1alpha2.ListImagesRequest) (*v1alpha2.ListImagesResponse, error)) {
	fake.listImagesMutex.Lock()
	defer fake.listImagesMutex.Unlock()
	fake.ListImagesStub = stub
}

func (fake *FakeContainerdCRIService) ListImagesArgsForCall(i int) (context.Context, *v1alpha2.ListImagesRequest) {
	fake.listImagesMutex.RLock()
	defer fake.listImagesMutex.RUnlock()
	argsForCall := fake.listImagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ListImagesReturns(result1 *v1alpha2.ListImagesResponse, result2 error) {
	fake.listImagesMutex.Lock()
	defer fake.listImagesMutex.Unlock()
	fake.ListImagesStub = nil
	fake.listImagesReturns = struct {
		result1 *v1alpha2.ListImagesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ListImagesReturnsOnCall(i int, result1 *v1alpha2.ListImagesResponse, result2 error) {
	fake.listImagesMutex.Lock()
	defer fake.listImagesMutex.Unlock()
	fake.ListImagesStub = nil
	if fake.listImagesReturnsOnCall == nil {
		fake.listImagesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ListImagesResponse
			result2 error
		})
	}
	fake.listImagesReturnsOnCall[i] = struct {
		result1 *v1alpha2.ListImagesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ListPodSandbox(arg1 context.Context, arg2 *v1alpha2.ListPodSandboxRequest) (*v1alpha2.ListPodSandboxResponse, error) {
	fake.listPodSandboxMutex.Lock()
	ret, specificReturn := fake.listPodSandboxReturnsOnCall[len(fake.listPodSandboxArgsForCall)]
	fake.listPodSandboxArgsForCall = append(fake.listPodSandboxArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ListPodSandboxRequest
	}{arg1, arg2})
	fake.recordInvocation("ListPodSandbox", []interface{}{arg1, arg2})
	fake.listPodSandboxMutex.Unlock()
	if fake.ListPodSandboxStub != nil {
		return fake.ListPodSandboxStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPodSandboxReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ListPodSandboxCallCount() int {
	fake.listPodSandboxMutex.RLock()
	defer fake.listPodSandboxMutex.RUnlock()
	return len(fake.listPodSandboxArgsForCall)
}

func (fake *FakeContainerdCRIService) ListPodSandboxCalls(stub func(context.Context, *v1alpha2.ListPodSandboxRequest) (*v1alpha2.ListPodSandboxResponse, error)) {
	fake.listPodSandboxMutex.Lock()
	defer fake.listPodSandboxMutex.Unlock()
	fake.ListPodSandboxStub = stub
}

func (fake *FakeContainerdCRIService) ListPodSandboxArgsForCall(i int) (context.Context, *v1alpha2.ListPodSandboxRequest) {
	fake.listPodSandboxMutex.RLock()
	defer fake.listPodSandboxMutex.RUnlock()
	argsForCall := fake.listPodSandboxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ListPodSandboxReturns(result1 *v1alpha2.ListPodSandboxResponse, result2 error) {
	fake.listPodSandboxMutex.Lock()
	defer fake.listPodSandboxMutex.Unlock()
	fake.ListPodSandboxStub = nil
	fake.listPodSandboxReturns = struct {
		result1 *v1alpha2.ListPodSandboxResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ListPodSandboxReturnsOnCall(i int, result1 *v1alpha2.ListPodSandboxResponse, result2 error) {
	fake.listPodSandboxMutex.Lock()
	defer fake.listPodSandboxMutex.Unlock()
	fake.ListPodSandboxStub = nil
	if fake.listPodSandboxReturnsOnCall == nil {
		fake.listPodSandboxReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ListPodSandboxResponse
			result2 error
		})
	}
	fake.listPodSandboxReturnsOnCall[i] = struct {
		result1 *v1alpha2.ListPodSandboxResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) PodSandboxStatus(arg1 context.Context, arg2 *v1alpha2.PodSandboxStatusRequest) (*v1alpha2.PodSandboxStatusResponse, error) {
	fake.podSandboxStatusMutex.Lock()
	ret, specificReturn := fake.podSandboxStatusReturnsOnCall[len(fake.podSandboxStatusArgsForCall)]
	fake.podSandboxStatusArgsForCall = append(fake.podSandboxStatusArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.PodSandboxStatusRequest
	}{arg1, arg2})
	fake.recordInvocation("PodSandboxStatus", []interface{}{arg1, arg2})
	fake.podSandboxStatusMutex.Unlock()
	if fake.PodSandboxStatusStub != nil {
		return fake.PodSandboxStatusStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.podSandboxStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) PodSandboxStatusCallCount() int {
	fake.podSandboxStatusMutex.RLock()
	defer fake.podSandboxStatusMutex.RUnlock()
	return len(fake.podSandboxStatusArgsForCall)
}

func (fake *FakeContainerdCRIService) PodSandboxStatusCalls(stub func(context.Context, *v1alpha2.PodSandboxStatusRequest) (*v1alpha2.PodSandboxStatusResponse, error)) {
	fake.podSandboxStatusMutex.Lock()
	defer fake.podSandboxStatusMutex.Unlock()
	fake.PodSandboxStatusStub = stub
}

func (fake *FakeContainerdCRIService) PodSandboxStatusArgsForCall(i int) (context.Context, *v1alpha2.PodSandboxStatusRequest) {
	fake.podSandboxStatusMutex.RLock()
	defer fake.podSandboxStatusMutex.RUnlock()
	argsForCall := fake.podSandboxStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) PodSandboxStatusReturns(result1 *v1alpha2.PodSandboxStatusResponse, result2 error) {
	fake.podSandboxStatusMutex.Lock()
	defer fake.podSandboxStatusMutex.Unlock()
	fake.PodSandboxStatusStub = nil
	fake.podSandboxStatusReturns = struct {
		result1 *v1alpha2.PodSandboxStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) PodSandboxStatusReturnsOnCall(i int, result1 *v1alpha2.PodSandboxStatusResponse, result2 error) {
	fake.podSandboxStatusMutex.Lock()
	defer fake.podSandboxStatusMutex.Unlock()
	fake.PodSandboxStatusStub = nil
	if fake.podSandboxStatusReturnsOnCall == nil {
		fake.podSandboxStatusReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.PodSandboxStatusResponse
			result2 error
		})
	}
	fake.podSandboxStatusReturnsOnCall[i] = struct {
		result1 *v1alpha2.PodSandboxStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) PortForward(arg1 context.Context, arg2 *v1alpha2.PortForwardRequest) (*v1alpha2.PortForwardResponse, error) {
	fake.portForwardMutex.Lock()
	ret, specificReturn := fake.portForwardReturnsOnCall[len(fake.portForwardArgsForCall)]
	fake.portForwardArgsForCall = append(fake.portForwardArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.PortForwardRequest
	}{arg1, arg2})
	fake.recordInvocation("PortForward", []interface{}{arg1, arg2})
	fake.portForwardMutex.Unlock()
	if fake.PortForwardStub != nil {
		return fake.PortForwardStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.portForwardReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) PortForwardCallCount() int {
	fake.portForwardMutex.RLock()
	defer fake.portForwardMutex.RUnlock()
	return len(fake.portForwardArgsForCall)
}

func (fake *FakeContainerdCRIService) PortForwardCalls(stub func(context.Context, *v1alpha2.PortForwardRequest) (*v1alpha2.PortForwardResponse, error)) {
	fake.portForwardMutex.Lock()
	defer fake.portForwardMutex.Unlock()
	fake.PortForwardStub = stub
}

func (fake *FakeContainerdCRIService) PortForwardArgsForCall(i int) (context.Context, *v1alpha2.PortForwardRequest) {
	fake.portForwardMutex.RLock()
	defer fake.portForwardMutex.RUnlock()
	argsForCall := fake.portForwardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) PortForwardReturns(result1 *v1alpha2.PortForwardResponse, result2 error) {
	fake.portForwardMutex.Lock()
	defer fake.portForwardMutex.Unlock()
	fake.PortForwardStub = nil
	fake.portForwardReturns = struct {
		result1 *v1alpha2.PortForwardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) PortForwardReturnsOnCall(i int, result1 *v1alpha2.PortForwardResponse, result2 error) {
	fake.portForwardMutex.Lock()
	defer fake.portForwardMutex.Unlock()
	fake.PortForwardStub = nil
	if fake.portForwardReturnsOnCall == nil {
		fake.portForwardReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.PortForwardResponse
			result2 error
		})
	}
	fake.portForwardReturnsOnCall[i] = struct {
		result1 *v1alpha2.PortForwardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) PullImage(arg1 context.Context, arg2 *v1alpha2.PullImageRequest) (*v1alpha2.PullImageResponse, error) {
	fake.pullImageMutex.Lock()
	ret, specificReturn := fake.pullImageReturnsOnCall[len(fake.pullImageArgsForCall)]
	fake.pullImageArgsForCall = append(fake.pullImageArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.PullImageRequest
	}{arg1, arg2})
	fake.recordInvocation("PullImage", []interface{}{arg1, arg2})
	fake.pullImageMutex.Unlock()
	if fake.PullImageStub != nil {
		return fake.PullImageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pullImageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) PullImageCallCount() int {
	fake.pullImageMutex.RLock()
	defer fake.pullImageMutex.RUnlock()
	return len(fake.pullImageArgsForCall)
}

func (fake *FakeContainerdCRIService) PullImageCalls(stub func(context.Context, *v1alpha2.PullImageRequest) (*v1alpha2.PullImageResponse, error)) {
	fake.pullImageMutex.Lock()
	defer fake.pullImageMutex.Unlock()
	fake.PullImageStub = stub
}

func (fake *FakeContainerdCRIService) PullImageArgsForCall(i int) (context.Context, *v1alpha2.PullImageRequest) {
	fake.pullImageMutex.RLock()
	defer fake.pullImageMutex.RUnlock()
	argsForCall := fake.pullImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) PullImageReturns(result1 *v1alpha2.PullImageResponse, result2 error) {
	fake.pullImageMutex.Lock()
	defer fake.pullImageMutex.Unlock()
	fake.PullImageStub = nil
	fake.pullImageReturns = struct {
		result1 *v1alpha2.PullImageResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) PullImageReturnsOnCall(i int, result1 *v1alpha2.PullImageResponse, result2 error) {
	fake.pullImageMutex.Lock()
	defer fake.pullImageMutex.Unlock()
	fake.PullImageStub = nil
	if fake.pullImageReturnsOnCall == nil {
		fake.pullImageReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.PullImageResponse
			result2 error
		})
	}
	fake.pullImageReturnsOnCall[i] = struct {
		result1 *v1alpha2.PullImageResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) Register(arg1 *grpc.Server) error {
	fake.registerMutex.Lock()
	ret, specificReturn := fake.registerReturnsOnCall[len(fake.registerArgsForCall)]
	fake.registerArgsForCall = append(fake.registerArgsForCall, struct {
		arg1 *grpc.Server
	}{arg1})
	fake.recordInvocation("Register", []interface{}{arg1})
	fake.registerMutex.Unlock()
	if fake.RegisterStub != nil {
		return fake.RegisterStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.registerReturns
	return fakeReturns.result1
}

func (fake *FakeContainerdCRIService) RegisterCallCount() int {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	return len(fake.registerArgsForCall)
}

func (fake *FakeContainerdCRIService) RegisterCalls(stub func(*grpc.Server) error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = stub
}

func (fake *FakeContainerdCRIService) RegisterArgsForCall(i int) *grpc.Server {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	argsForCall := fake.registerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerdCRIService) RegisterReturns(result1 error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	fake.registerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerdCRIService) RegisterReturnsOnCall(i int, result1 error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	if fake.registerReturnsOnCall == nil {
		fake.registerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerdCRIService) RemoveContainer(arg1 context.Context, arg2 *v1alpha2.RemoveContainerRequest) (*v1alpha2.RemoveContainerResponse, error) {
	fake.removeContainerMutex.Lock()
	ret, specificReturn := fake.removeContainerReturnsOnCall[len(fake.removeContainerArgsForCall)]
	fake.removeContainerArgsForCall = append(fake.removeContainerArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.RemoveContainerRequest
	}{arg1, arg2})
	fake.recordInvocation("RemoveContainer", []interface{}{arg1, arg2})
	fake.removeContainerMutex.Unlock()
	if fake.RemoveContainerStub != nil {
		return fake.RemoveContainerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removeContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) RemoveContainerCallCount() int {
	fake.removeContainerMutex.RLock()
	defer fake.removeContainerMutex.RUnlock()
	return len(fake.removeContainerArgsForCall)
}

func (fake *FakeContainerdCRIService) RemoveContainerCalls(stub func(context.Context, *v1alpha2.RemoveContainerRequest) (*v1alpha2.RemoveContainerResponse, error)) {
	fake.removeContainerMutex.Lock()
	defer fake.removeContainerMutex.Unlock()
	fake.RemoveContainerStub = stub
}

func (fake *FakeContainerdCRIService) RemoveContainerArgsForCall(i int) (context.Context, *v1alpha2.RemoveContainerRequest) {
	fake.removeContainerMutex.RLock()
	defer fake.removeContainerMutex.RUnlock()
	argsForCall := fake.removeContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) RemoveContainerReturns(result1 *v1alpha2.RemoveContainerResponse, result2 error) {
	fake.removeContainerMutex.Lock()
	defer fake.removeContainerMutex.Unlock()
	fake.RemoveContainerStub = nil
	fake.removeContainerReturns = struct {
		result1 *v1alpha2.RemoveContainerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) RemoveContainerReturnsOnCall(i int, result1 *v1alpha2.RemoveContainerResponse, result2 error) {
	fake.removeContainerMutex.Lock()
	defer fake.removeContainerMutex.Unlock()
	fake.RemoveContainerStub = nil
	if fake.removeContainerReturnsOnCall == nil {
		fake.removeContainerReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.RemoveContainerResponse
			result2 error
		})
	}
	fake.removeContainerReturnsOnCall[i] = struct {
		result1 *v1alpha2.RemoveContainerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) RemoveImage(arg1 context.Context, arg2 *v1alpha2.RemoveImageRequest) (*v1alpha2.RemoveImageResponse, error) {
	fake.removeImageMutex.Lock()
	ret, specificReturn := fake.removeImageReturnsOnCall[len(fake.removeImageArgsForCall)]
	fake.removeImageArgsForCall = append(fake.removeImageArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.RemoveImageRequest
	}{arg1, arg2})
	fake.recordInvocation("RemoveImage", []interface{}{arg1, arg2})
	fake.removeImageMutex.Unlock()
	if fake.RemoveImageStub != nil {
		return fake.RemoveImageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removeImageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) RemoveImageCallCount() int {
	fake.removeImageMutex.RLock()
	defer fake.removeImageMutex.RUnlock()
	return len(fake.removeImageArgsForCall)
}

func (fake *FakeContainerdCRIService) RemoveImageCalls(stub func(context.Context, *v1alpha2.RemoveImageRequest) (*v1alpha2.RemoveImageResponse, error)) {
	fake.removeImageMutex.Lock()
	defer fake.removeImageMutex.Unlock()
	fake.RemoveImageStub = stub
}

func (fake *FakeContainerdCRIService) RemoveImageArgsForCall(i int) (context.Context, *v1alpha2.RemoveImageRequest) {
	fake.removeImageMutex.RLock()
	defer fake.removeImageMutex.RUnlock()
	argsForCall := fake.removeImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) RemoveImageReturns(result1 *v1alpha2.RemoveImageResponse, result2 error) {
	fake.removeImageMutex.Lock()
	defer fake.removeImageMutex.Unlock()
	fake.RemoveImageStub = nil
	fake.removeImageReturns = struct {
		result1 *v1alpha2.RemoveImageResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) RemoveImageReturnsOnCall(i int, result1 *v1alpha2.RemoveImageResponse, result2 error) {
	fake.removeImageMutex.Lock()
	defer fake.removeImageMutex.Unlock()
	fake.RemoveImageStub = nil
	if fake.removeImageReturnsOnCall == nil {
		fake.removeImageReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.RemoveImageResponse
			result2 error
		})
	}
	fake.removeImageReturnsOnCall[i] = struct {
		result1 *v1alpha2.RemoveImageResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) RemovePodSandbox(arg1 context.Context, arg2 *v1alpha2.RemovePodSandboxRequest) (*v1alpha2.RemovePodSandboxResponse, error) {
	fake.removePodSandboxMutex.Lock()
	ret, specificReturn := fake.removePodSandboxReturnsOnCall[len(fake.removePodSandboxArgsForCall)]
	fake.removePodSandboxArgsForCall = append(fake.removePodSandboxArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.RemovePodSandboxRequest
	}{arg1, arg2})
	fake.recordInvocation("RemovePodSandbox", []interface{}{arg1, arg2})
	fake.removePodSandboxMutex.Unlock()
	if fake.RemovePodSandboxStub != nil {
		return fake.RemovePodSandboxStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removePodSandboxReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) RemovePodSandboxCallCount() int {
	fake.removePodSandboxMutex.RLock()
	defer fake.removePodSandboxMutex.RUnlock()
	return len(fake.removePodSandboxArgsForCall)
}

func (fake *FakeContainerdCRIService) RemovePodSandboxCalls(stub func(context.Context, *v1alpha2.RemovePodSandboxRequest) (*v1alpha2.RemovePodSandboxResponse, error)) {
	fake.removePodSandboxMutex.Lock()
	defer fake.removePodSandboxMutex.Unlock()
	fake.RemovePodSandboxStub = stub
}

func (fake *FakeContainerdCRIService) RemovePodSandboxArgsForCall(i int) (context.Context, *v1alpha2.RemovePodSandboxRequest) {
	fake.removePodSandboxMutex.RLock()
	defer fake.removePodSandboxMutex.RUnlock()
	argsForCall := fake.removePodSandboxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) RemovePodSandboxReturns(result1 *v1alpha2.RemovePodSandboxResponse, result2 error) {
	fake.removePodSandboxMutex.Lock()
	defer fake.removePodSandboxMutex.Unlock()
	fake.RemovePodSandboxStub = nil
	fake.removePodSandboxReturns = struct {
		result1 *v1alpha2.RemovePodSandboxResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) RemovePodSandboxReturnsOnCall(i int, result1 *v1alpha2.RemovePodSandboxResponse, result2 error) {
	fake.removePodSandboxMutex.Lock()
	defer fake.removePodSandboxMutex.Unlock()
	fake.RemovePodSandboxStub = nil
	if fake.removePodSandboxReturnsOnCall == nil {
		fake.removePodSandboxReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.RemovePodSandboxResponse
			result2 error
		})
	}
	fake.removePodSandboxReturnsOnCall[i] = struct {
		result1 *v1alpha2.RemovePodSandboxResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ReopenContainerLog(arg1 context.Context, arg2 *v1alpha2.ReopenContainerLogRequest) (*v1alpha2.ReopenContainerLogResponse, error) {
	fake.reopenContainerLogMutex.Lock()
	ret, specificReturn := fake.reopenContainerLogReturnsOnCall[len(fake.reopenContainerLogArgsForCall)]
	fake.reopenContainerLogArgsForCall = append(fake.reopenContainerLogArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.ReopenContainerLogRequest
	}{arg1, arg2})
	fake.recordInvocation("ReopenContainerLog", []interface{}{arg1, arg2})
	fake.reopenContainerLogMutex.Unlock()
	if fake.ReopenContainerLogStub != nil {
		return fake.ReopenContainerLogStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.reopenContainerLogReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) ReopenContainerLogCallCount() int {
	fake.reopenContainerLogMutex.RLock()
	defer fake.reopenContainerLogMutex.RUnlock()
	return len(fake.reopenContainerLogArgsForCall)
}

func (fake *FakeContainerdCRIService) ReopenContainerLogCalls(stub func(context.Context, *v1alpha2.ReopenContainerLogRequest) (*v1alpha2.ReopenContainerLogResponse, error)) {
	fake.reopenContainerLogMutex.Lock()
	defer fake.reopenContainerLogMutex.Unlock()
	fake.ReopenContainerLogStub = stub
}

func (fake *FakeContainerdCRIService) ReopenContainerLogArgsForCall(i int) (context.Context, *v1alpha2.ReopenContainerLogRequest) {
	fake.reopenContainerLogMutex.RLock()
	defer fake.reopenContainerLogMutex.RUnlock()
	argsForCall := fake.reopenContainerLogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) ReopenContainerLogReturns(result1 *v1alpha2.ReopenContainerLogResponse, result2 error) {
	fake.reopenContainerLogMutex.Lock()
	defer fake.reopenContainerLogMutex.Unlock()
	fake.ReopenContainerLogStub = nil
	fake.reopenContainerLogReturns = struct {
		result1 *v1alpha2.ReopenContainerLogResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) ReopenContainerLogReturnsOnCall(i int, result1 *v1alpha2.ReopenContainerLogResponse, result2 error) {
	fake.reopenContainerLogMutex.Lock()
	defer fake.reopenContainerLogMutex.Unlock()
	fake.ReopenContainerLogStub = nil
	if fake.reopenContainerLogReturnsOnCall == nil {
		fake.reopenContainerLogReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.ReopenContainerLogResponse
			result2 error
		})
	}
	fake.reopenContainerLogReturnsOnCall[i] = struct {
		result1 *v1alpha2.ReopenContainerLogResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) Run() error {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
	}{})
	fake.recordInvocation("Run", []interface{}{})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.runReturns
	return fakeReturns.result1
}

func (fake *FakeContainerdCRIService) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeContainerdCRIService) RunCalls(stub func() error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeContainerdCRIService) RunReturns(result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerdCRIService) RunReturnsOnCall(i int, result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerdCRIService) RunPodSandbox(arg1 context.Context, arg2 *v1alpha2.RunPodSandboxRequest) (*v1alpha2.RunPodSandboxResponse, error) {
	fake.runPodSandboxMutex.Lock()
	ret, specificReturn := fake.runPodSandboxReturnsOnCall[len(fake.runPodSandboxArgsForCall)]
	fake.runPodSandboxArgsForCall = append(fake.runPodSandboxArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.RunPodSandboxRequest
	}{arg1, arg2})
	fake.recordInvocation("RunPodSandbox", []interface{}{arg1, arg2})
	fake.runPodSandboxMutex.Unlock()
	if fake.RunPodSandboxStub != nil {
		return fake.RunPodSandboxStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.runPodSandboxReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) RunPodSandboxCallCount() int {
	fake.runPodSandboxMutex.RLock()
	defer fake.runPodSandboxMutex.RUnlock()
	return len(fake.runPodSandboxArgsForCall)
}

func (fake *FakeContainerdCRIService) RunPodSandboxCalls(stub func(context.Context, *v1alpha2.RunPodSandboxRequest) (*v1alpha2.RunPodSandboxResponse, error)) {
	fake.runPodSandboxMutex.Lock()
	defer fake.runPodSandboxMutex.Unlock()
	fake.RunPodSandboxStub = stub
}

func (fake *FakeContainerdCRIService) RunPodSandboxArgsForCall(i int) (context.Context, *v1alpha2.RunPodSandboxRequest) {
	fake.runPodSandboxMutex.RLock()
	defer fake.runPodSandboxMutex.RUnlock()
	argsForCall := fake.runPodSandboxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) RunPodSandboxReturns(result1 *v1alpha2.RunPodSandboxResponse, result2 error) {
	fake.runPodSandboxMutex.Lock()
	defer fake.runPodSandboxMutex.Unlock()
	fake.RunPodSandboxStub = nil
	fake.runPodSandboxReturns = struct {
		result1 *v1alpha2.RunPodSandboxResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) RunPodSandboxReturnsOnCall(i int, result1 *v1alpha2.RunPodSandboxResponse, result2 error) {
	fake.runPodSandboxMutex.Lock()
	defer fake.runPodSandboxMutex.Unlock()
	fake.RunPodSandboxStub = nil
	if fake.runPodSandboxReturnsOnCall == nil {
		fake.runPodSandboxReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.RunPodSandboxResponse
			result2 error
		})
	}
	fake.runPodSandboxReturnsOnCall[i] = struct {
		result1 *v1alpha2.RunPodSandboxResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) StartContainer(arg1 context.Context, arg2 *v1alpha2.StartContainerRequest) (*v1alpha2.StartContainerResponse, error) {
	fake.startContainerMutex.Lock()
	ret, specificReturn := fake.startContainerReturnsOnCall[len(fake.startContainerArgsForCall)]
	fake.startContainerArgsForCall = append(fake.startContainerArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.StartContainerRequest
	}{arg1, arg2})
	fake.recordInvocation("StartContainer", []interface{}{arg1, arg2})
	fake.startContainerMutex.Unlock()
	if fake.StartContainerStub != nil {
		return fake.StartContainerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.startContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) StartContainerCallCount() int {
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	return len(fake.startContainerArgsForCall)
}

func (fake *FakeContainerdCRIService) StartContainerCalls(stub func(context.Context, *v1alpha2.StartContainerRequest) (*v1alpha2.StartContainerResponse, error)) {
	fake.startContainerMutex.Lock()
	defer fake.startContainerMutex.Unlock()
	fake.StartContainerStub = stub
}

func (fake *FakeContainerdCRIService) StartContainerArgsForCall(i int) (context.Context, *v1alpha2.StartContainerRequest) {
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	argsForCall := fake.startContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) StartContainerReturns(result1 *v1alpha2.StartContainerResponse, result2 error) {
	fake.startContainerMutex.Lock()
	defer fake.startContainerMutex.Unlock()
	fake.StartContainerStub = nil
	fake.startContainerReturns = struct {
		result1 *v1alpha2.StartContainerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) StartContainerReturnsOnCall(i int, result1 *v1alpha2.StartContainerResponse, result2 error) {
	fake.startContainerMutex.Lock()
	defer fake.startContainerMutex.Unlock()
	fake.StartContainerStub = nil
	if fake.startContainerReturnsOnCall == nil {
		fake.startContainerReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.StartContainerResponse
			result2 error
		})
	}
	fake.startContainerReturnsOnCall[i] = struct {
		result1 *v1alpha2.StartContainerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) Status(arg1 context.Context, arg2 *v1alpha2.StatusRequest) (*v1alpha2.StatusResponse, error) {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.StatusRequest
	}{arg1, arg2})
	fake.recordInvocation("Status", []interface{}{arg1, arg2})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.statusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeContainerdCRIService) StatusCalls(stub func(context.Context, *v1alpha2.StatusRequest) (*v1alpha2.StatusResponse, error)) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeContainerdCRIService) StatusArgsForCall(i int) (context.Context, *v1alpha2.StatusRequest) {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	argsForCall := fake.statusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) StatusReturns(result1 *v1alpha2.StatusResponse, result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 *v1alpha2.StatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) StatusReturnsOnCall(i int, result1 *v1alpha2.StatusResponse, result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.StatusResponse
			result2 error
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 *v1alpha2.StatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) StopContainer(arg1 context.Context, arg2 *v1alpha2.StopContainerRequest) (*v1alpha2.StopContainerResponse, error) {
	fake.stopContainerMutex.Lock()
	ret, specificReturn := fake.stopContainerReturnsOnCall[len(fake.stopContainerArgsForCall)]
	fake.stopContainerArgsForCall = append(fake.stopContainerArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.StopContainerRequest
	}{arg1, arg2})
	fake.recordInvocation("StopContainer", []interface{}{arg1, arg2})
	fake.stopContainerMutex.Unlock()
	if fake.StopContainerStub != nil {
		return fake.StopContainerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.stopContainerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) StopContainerCallCount() int {
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	return len(fake.stopContainerArgsForCall)
}

func (fake *FakeContainerdCRIService) StopContainerCalls(stub func(context.Context, *v1alpha2.StopContainerRequest) (*v1alpha2.StopContainerResponse, error)) {
	fake.stopContainerMutex.Lock()
	defer fake.stopContainerMutex.Unlock()
	fake.StopContainerStub = stub
}

func (fake *FakeContainerdCRIService) StopContainerArgsForCall(i int) (context.Context, *v1alpha2.StopContainerRequest) {
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	argsForCall := fake.stopContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) StopContainerReturns(result1 *v1alpha2.StopContainerResponse, result2 error) {
	fake.stopContainerMutex.Lock()
	defer fake.stopContainerMutex.Unlock()
	fake.StopContainerStub = nil
	fake.stopContainerReturns = struct {
		result1 *v1alpha2.StopContainerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) StopContainerReturnsOnCall(i int, result1 *v1alpha2.StopContainerResponse, result2 error) {
	fake.stopContainerMutex.Lock()
	defer fake.stopContainerMutex.Unlock()
	fake.StopContainerStub = nil
	if fake.stopContainerReturnsOnCall == nil {
		fake.stopContainerReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.StopContainerResponse
			result2 error
		})
	}
	fake.stopContainerReturnsOnCall[i] = struct {
		result1 *v1alpha2.StopContainerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) StopPodSandbox(arg1 context.Context, arg2 *v1alpha2.StopPodSandboxRequest) (*v1alpha2.StopPodSandboxResponse, error) {
	fake.stopPodSandboxMutex.Lock()
	ret, specificReturn := fake.stopPodSandboxReturnsOnCall[len(fake.stopPodSandboxArgsForCall)]
	fake.stopPodSandboxArgsForCall = append(fake.stopPodSandboxArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.StopPodSandboxRequest
	}{arg1, arg2})
	fake.recordInvocation("StopPodSandbox", []interface{}{arg1, arg2})
	fake.stopPodSandboxMutex.Unlock()
	if fake.StopPodSandboxStub != nil {
		return fake.StopPodSandboxStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.stopPodSandboxReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) StopPodSandboxCallCount() int {
	fake.stopPodSandboxMutex.RLock()
	defer fake.stopPodSandboxMutex.RUnlock()
	return len(fake.stopPodSandboxArgsForCall)
}

func (fake *FakeContainerdCRIService) StopPodSandboxCalls(stub func(context.Context, *v1alpha2.StopPodSandboxRequest) (*v1alpha2.StopPodSandboxResponse, error)) {
	fake.stopPodSandboxMutex.Lock()
	defer fake.stopPodSandboxMutex.Unlock()
	fake.StopPodSandboxStub = stub
}

func (fake *FakeContainerdCRIService) StopPodSandboxArgsForCall(i int) (context.Context, *v1alpha2.StopPodSandboxRequest) {
	fake.stopPodSandboxMutex.RLock()
	defer fake.stopPodSandboxMutex.RUnlock()
	argsForCall := fake.stopPodSandboxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) StopPodSandboxReturns(result1 *v1alpha2.StopPodSandboxResponse, result2 error) {
	fake.stopPodSandboxMutex.Lock()
	defer fake.stopPodSandboxMutex.Unlock()
	fake.StopPodSandboxStub = nil
	fake.stopPodSandboxReturns = struct {
		result1 *v1alpha2.StopPodSandboxResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) StopPodSandboxReturnsOnCall(i int, result1 *v1alpha2.StopPodSandboxResponse, result2 error) {
	fake.stopPodSandboxMutex.Lock()
	defer fake.stopPodSandboxMutex.Unlock()
	fake.StopPodSandboxStub = nil
	if fake.stopPodSandboxReturnsOnCall == nil {
		fake.stopPodSandboxReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.StopPodSandboxResponse
			result2 error
		})
	}
	fake.stopPodSandboxReturnsOnCall[i] = struct {
		result1 *v1alpha2.StopPodSandboxResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) UpdateContainerResources(arg1 context.Context, arg2 *v1alpha2.UpdateContainerResourcesRequest) (*v1alpha2.UpdateContainerResourcesResponse, error) {
	fake.updateContainerResourcesMutex.Lock()
	ret, specificReturn := fake.updateContainerResourcesReturnsOnCall[len(fake.updateContainerResourcesArgsForCall)]
	fake.updateContainerResourcesArgsForCall = append(fake.updateContainerResourcesArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.UpdateContainerResourcesRequest
	}{arg1, arg2})
	fake.recordInvocation("UpdateContainerResources", []interface{}{arg1, arg2})
	fake.updateContainerResourcesMutex.Unlock()
	if fake.UpdateContainerResourcesStub != nil {
		return fake.UpdateContainerResourcesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateContainerResourcesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) UpdateContainerResourcesCallCount() int {
	fake.updateContainerResourcesMutex.RLock()
	defer fake.updateContainerResourcesMutex.RUnlock()
	return len(fake.updateContainerResourcesArgsForCall)
}

func (fake *FakeContainerdCRIService) UpdateContainerResourcesCalls(stub func(context.Context, *v1alpha2.UpdateContainerResourcesRequest) (*v1alpha2.UpdateContainerResourcesResponse, error)) {
	fake.updateContainerResourcesMutex.Lock()
	defer fake.updateContainerResourcesMutex.Unlock()
	fake.UpdateContainerResourcesStub = stub
}

func (fake *FakeContainerdCRIService) UpdateContainerResourcesArgsForCall(i int) (context.Context, *v1alpha2.UpdateContainerResourcesRequest) {
	fake.updateContainerResourcesMutex.RLock()
	defer fake.updateContainerResourcesMutex.RUnlock()
	argsForCall := fake.updateContainerResourcesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) UpdateContainerResourcesReturns(result1 *v1alpha2.UpdateContainerResourcesResponse, result2 error) {
	fake.updateContainerResourcesMutex.Lock()
	defer fake.updateContainerResourcesMutex.Unlock()
	fake.UpdateContainerResourcesStub = nil
	fake.updateContainerResourcesReturns = struct {
		result1 *v1alpha2.UpdateContainerResourcesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) UpdateContainerResourcesReturnsOnCall(i int, result1 *v1alpha2.UpdateContainerResourcesResponse, result2 error) {
	fake.updateContainerResourcesMutex.Lock()
	defer fake.updateContainerResourcesMutex.Unlock()
	fake.UpdateContainerResourcesStub = nil
	if fake.updateContainerResourcesReturnsOnCall == nil {
		fake.updateContainerResourcesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.UpdateContainerResourcesResponse
			result2 error
		})
	}
	fake.updateContainerResourcesReturnsOnCall[i] = struct {
		result1 *v1alpha2.UpdateContainerResourcesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) UpdateRuntimeConfig(arg1 context.Context, arg2 *v1alpha2.UpdateRuntimeConfigRequest) (*v1alpha2.UpdateRuntimeConfigResponse, error) {
	fake.updateRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.updateRuntimeConfigReturnsOnCall[len(fake.updateRuntimeConfigArgsForCall)]
	fake.updateRuntimeConfigArgsForCall = append(fake.updateRuntimeConfigArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.UpdateRuntimeConfigRequest
	}{arg1, arg2})
	fake.recordInvocation("UpdateRuntimeConfig", []interface{}{arg1, arg2})
	fake.updateRuntimeConfigMutex.Unlock()
	if fake.UpdateRuntimeConfigStub != nil {
		return fake.UpdateRuntimeConfigStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateRuntimeConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) UpdateRuntimeConfigCallCount() int {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	return len(fake.updateRuntimeConfigArgsForCall)
}

func (fake *FakeContainerdCRIService) UpdateRuntimeConfigCalls(stub func(context.Context, *v1alpha2.UpdateRuntimeConfigRequest) (*v1alpha2.UpdateRuntimeConfigResponse, error)) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = stub
}

func (fake *FakeContainerdCRIService) UpdateRuntimeConfigArgsForCall(i int) (context.Context, *v1alpha2.UpdateRuntimeConfigRequest) {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	argsForCall := fake.updateRuntimeConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) UpdateRuntimeConfigReturns(result1 *v1alpha2.UpdateRuntimeConfigResponse, result2 error) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = nil
	fake.updateRuntimeConfigReturns = struct {
		result1 *v1alpha2.UpdateRuntimeConfigResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) UpdateRuntimeConfigReturnsOnCall(i int, result1 *v1alpha2.UpdateRuntimeConfigResponse, result2 error) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = nil
	if fake.updateRuntimeConfigReturnsOnCall == nil {
		fake.updateRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.UpdateRuntimeConfigResponse
			result2 error
		})
	}
	fake.updateRuntimeConfigReturnsOnCall[i] = struct {
		result1 *v1alpha2.UpdateRuntimeConfigResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) Version(arg1 context.Context, arg2 *v1alpha2.VersionRequest) (*v1alpha2.VersionResponse, error) {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha2.VersionRequest
	}{arg1, arg2})
	fake.recordInvocation("Version", []interface{}{arg1, arg2})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.versionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerdCRIService) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeContainerdCRIService) VersionCalls(stub func(context.Context, *v1alpha2.VersionRequest) (*v1alpha2.VersionResponse, error)) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = stub
}

func (fake *FakeContainerdCRIService) VersionArgsForCall(i int) (context.Context, *v1alpha2.VersionRequest) {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	argsForCall := fake.versionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerdCRIService) VersionReturns(result1 *v1alpha2.VersionResponse, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 *v1alpha2.VersionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) VersionReturnsOnCall(i int, result1 *v1alpha2.VersionResponse, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 *v1alpha2.VersionResponse
			result2 error
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 *v1alpha2.VersionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerdCRIService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	fake.containerStatusMutex.RLock()
	defer fake.containerStatusMutex.RUnlock()
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	fake.execSyncMutex.RLock()
	defer fake.execSyncMutex.RUnlock()
	fake.imageFsInfoMutex.RLock()
	defer fake.imageFsInfoMutex.RUnlock()
	fake.imageStatusMutex.RLock()
	defer fake.imageStatusMutex.RUnlock()
	fake.listContainerStatsMutex.RLock()
	defer fake.listContainerStatsMutex.RUnlock()
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	fake.listImagesMutex.RLock()
	defer fake.listImagesMutex.RUnlock()
	fake.listPodSandboxMutex.RLock()
	defer fake.listPodSandboxMutex.RUnlock()
	fake.podSandboxStatusMutex.RLock()
	defer fake.podSandboxStatusMutex.RUnlock()
	fake.portForwardMutex.RLock()
	defer fake.portForwardMutex.RUnlock()
	fake.pullImageMutex.RLock()
	defer fake.pullImageMutex.RUnlock()
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	fake.removeContainerMutex.RLock()
	defer fake.removeContainerMutex.RUnlock()
	fake.removeImageMutex.RLock()
	defer fake.removeImageMutex.RUnlock()
	fake.removePodSandboxMutex.RLock()
	defer fake.removePodSandboxMutex.RUnlock()
	fake.reopenContainerLogMutex.RLock()
	defer fake.reopenContainerLogMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.runPodSandboxMutex.RLock()
	defer fake.runPodSandboxMutex.RUnlock()
	fake.startContainerMutex.RLock()
	defer fake.startContainerMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	fake.stopPodSandboxMutex.RLock()
	defer fake.stopPodSandboxMutex.RUnlock()
	fake.updateContainerResourcesMutex.RLock()
	defer fake.updateContainerResourcesMutex.RUnlock()
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainerdCRIService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.ContainerdCRIService = new(FakeContainerdCRIService)
