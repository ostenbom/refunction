// Code generated by counterfeiter. DO NOT EDIT.
package controllerfakes

import (
	"io"
	"sync"
	"syscall"

	"github.com/ostenbom/refunction/controller"
	"github.com/ostenbom/refunction/state"
)

type FakeController struct {
	ActivateStub        func() error
	activateMutex       sync.RWMutex
	activateArgsForCall []struct {
	}
	activateReturns struct {
		result1 error
	}
	activateReturnsOnCall map[int]struct {
		result1 error
	}
	AttachStub        func() error
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
	}
	attachReturns struct {
		result1 error
	}
	attachReturnsOnCall map[int]struct {
		result1 error
	}
	AwaitMessageStub        func(string) controller.Message
	awaitMessageMutex       sync.RWMutex
	awaitMessageArgsForCall []struct {
		arg1 string
	}
	awaitMessageReturns struct {
		result1 controller.Message
	}
	awaitMessageReturnsOnCall map[int]struct {
		result1 controller.Message
	}
	AwaitSignalStub        func(syscall.Signal)
	awaitSignalMutex       sync.RWMutex
	awaitSignalArgsForCall []struct {
		arg1 syscall.Signal
	}
	CheckpointsStub        func() []*state.State
	checkpointsMutex       sync.RWMutex
	checkpointsArgsForCall []struct {
	}
	checkpointsReturns struct {
		result1 []*state.State
	}
	checkpointsReturnsOnCall map[int]struct {
		result1 []*state.State
	}
	ClearMemRefsStub        func() error
	clearMemRefsMutex       sync.RWMutex
	clearMemRefsArgsForCall []struct {
	}
	clearMemRefsReturns struct {
		result1 error
	}
	clearMemRefsReturnsOnCall map[int]struct {
		result1 error
	}
	ContinueStub        func()
	continueMutex       sync.RWMutex
	continueArgsForCall []struct {
	}
	ContinueTidStub        func(int, syscall.Signal)
	continueTidMutex       sync.RWMutex
	continueTidArgsForCall []struct {
		arg1 int
		arg2 syscall.Signal
	}
	ContinueWithStub        func(syscall.Signal)
	continueWithMutex       sync.RWMutex
	continueWithArgsForCall []struct {
		arg1 syscall.Signal
	}
	DetachStub        func() error
	detachMutex       sync.RWMutex
	detachArgsForCall []struct {
	}
	detachReturns struct {
		result1 error
	}
	detachReturnsOnCall map[int]struct {
		result1 error
	}
	EndStub        func() error
	endMutex       sync.RWMutex
	endArgsForCall []struct {
	}
	endReturns struct {
		result1 error
	}
	endReturnsOnCall map[int]struct {
		result1 error
	}
	InitialCheckpointStub        func() (*state.State, error)
	initialCheckpointMutex       sync.RWMutex
	initialCheckpointArgsForCall []struct {
	}
	initialCheckpointReturns struct {
		result1 *state.State
		result2 error
	}
	initialCheckpointReturnsOnCall map[int]struct {
		result1 *state.State
		result2 error
	}
	PauseAtSignalStub        func(syscall.Signal)
	pauseAtSignalMutex       sync.RWMutex
	pauseAtSignalArgsForCall []struct {
		arg1 syscall.Signal
	}
	PidStub        func() int
	pidMutex       sync.RWMutex
	pidArgsForCall []struct {
	}
	pidReturns struct {
		result1 int
	}
	pidReturnsOnCall map[int]struct {
		result1 int
	}
	RestoreStub        func() error
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct {
	}
	restoreReturns struct {
		result1 error
	}
	restoreReturnsOnCall map[int]struct {
		result1 error
	}
	SendFunctionStub        func(string) error
	sendFunctionMutex       sync.RWMutex
	sendFunctionArgsForCall []struct {
		arg1 string
	}
	sendFunctionReturns struct {
		result1 error
	}
	sendFunctionReturnsOnCall map[int]struct {
		result1 error
	}
	SendMessageStub        func(string, interface{}) error
	sendMessageMutex       sync.RWMutex
	sendMessageArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	sendMessageReturns struct {
		result1 error
	}
	sendMessageReturnsOnCall map[int]struct {
		result1 error
	}
	SendRequestStub        func(interface{}) (interface{}, error)
	sendRequestMutex       sync.RWMutex
	sendRequestArgsForCall []struct {
		arg1 interface{}
	}
	sendRequestReturns struct {
		result1 interface{}
		result2 error
	}
	sendRequestReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	SendSignalStub        func(syscall.Signal) error
	sendSignalMutex       sync.RWMutex
	sendSignalArgsForCall []struct {
		arg1 syscall.Signal
	}
	sendSignalReturns struct {
		result1 error
	}
	sendSignalReturnsOnCall map[int]struct {
		result1 error
	}
	SendSignalContStub        func(syscall.Signal) error
	sendSignalContMutex       sync.RWMutex
	sendSignalContArgsForCall []struct {
		arg1 syscall.Signal
	}
	sendSignalContReturns struct {
		result1 error
	}
	sendSignalContReturnsOnCall map[int]struct {
		result1 error
	}
	SetPidStub        func(int)
	setPidMutex       sync.RWMutex
	setPidArgsForCall []struct {
		arg1 int
	}
	SetRegsStub        func(*state.State) error
	setRegsMutex       sync.RWMutex
	setRegsArgsForCall []struct {
		arg1 *state.State
	}
	setRegsReturns struct {
		result1 error
	}
	setRegsReturnsOnCall map[int]struct {
		result1 error
	}
	SetStreamsStub        func(*io.PipeWriter, *io.PipeReader, *io.PipeReader)
	setStreamsMutex       sync.RWMutex
	setStreamsArgsForCall []struct {
		arg1 *io.PipeWriter
		arg2 *io.PipeReader
		arg3 *io.PipeReader
	}
	StateStub        func() (*state.State, error)
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 *state.State
		result2 error
	}
	stateReturnsOnCall map[int]struct {
		result1 *state.State
		result2 error
	}
	StopStub        func() error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	StreamsStub        func() (*io.PipeWriter, *io.PipeReader, *io.PipeReader)
	streamsMutex       sync.RWMutex
	streamsArgsForCall []struct {
	}
	streamsReturns struct {
		result1 *io.PipeWriter
		result2 *io.PipeReader
		result3 *io.PipeReader
	}
	streamsReturnsOnCall map[int]struct {
		result1 *io.PipeWriter
		result2 *io.PipeReader
		result3 *io.PipeReader
	}
	TakeCheckpointStub        func() error
	takeCheckpointMutex       sync.RWMutex
	takeCheckpointArgsForCall []struct {
	}
	takeCheckpointReturns struct {
		result1 error
	}
	takeCheckpointReturnsOnCall map[int]struct {
		result1 error
	}
	WithSyscallTraceStub        func(io.Writer)
	withSyscallTraceMutex       sync.RWMutex
	withSyscallTraceArgsForCall []struct {
		arg1 io.Writer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeController) Activate() error {
	fake.activateMutex.Lock()
	ret, specificReturn := fake.activateReturnsOnCall[len(fake.activateArgsForCall)]
	fake.activateArgsForCall = append(fake.activateArgsForCall, struct {
	}{})
	fake.recordInvocation("Activate", []interface{}{})
	fake.activateMutex.Unlock()
	if fake.ActivateStub != nil {
		return fake.ActivateStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.activateReturns
	return fakeReturns.result1
}

func (fake *FakeController) ActivateCallCount() int {
	fake.activateMutex.RLock()
	defer fake.activateMutex.RUnlock()
	return len(fake.activateArgsForCall)
}

func (fake *FakeController) ActivateCalls(stub func() error) {
	fake.activateMutex.Lock()
	defer fake.activateMutex.Unlock()
	fake.ActivateStub = stub
}

func (fake *FakeController) ActivateReturns(result1 error) {
	fake.activateMutex.Lock()
	defer fake.activateMutex.Unlock()
	fake.ActivateStub = nil
	fake.activateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) ActivateReturnsOnCall(i int, result1 error) {
	fake.activateMutex.Lock()
	defer fake.activateMutex.Unlock()
	fake.ActivateStub = nil
	if fake.activateReturnsOnCall == nil {
		fake.activateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.activateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Attach() error {
	fake.attachMutex.Lock()
	ret, specificReturn := fake.attachReturnsOnCall[len(fake.attachArgsForCall)]
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
	}{})
	fake.recordInvocation("Attach", []interface{}{})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachReturns
	return fakeReturns.result1
}

func (fake *FakeController) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeController) AttachCalls(stub func() error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = stub
}

func (fake *FakeController) AttachReturns(result1 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AttachReturnsOnCall(i int, result1 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	if fake.attachReturnsOnCall == nil {
		fake.attachReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AwaitMessage(arg1 string) controller.Message {
	fake.awaitMessageMutex.Lock()
	ret, specificReturn := fake.awaitMessageReturnsOnCall[len(fake.awaitMessageArgsForCall)]
	fake.awaitMessageArgsForCall = append(fake.awaitMessageArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("AwaitMessage", []interface{}{arg1})
	fake.awaitMessageMutex.Unlock()
	if fake.AwaitMessageStub != nil {
		return fake.AwaitMessageStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.awaitMessageReturns
	return fakeReturns.result1
}

func (fake *FakeController) AwaitMessageCallCount() int {
	fake.awaitMessageMutex.RLock()
	defer fake.awaitMessageMutex.RUnlock()
	return len(fake.awaitMessageArgsForCall)
}

func (fake *FakeController) AwaitMessageCalls(stub func(string) controller.Message) {
	fake.awaitMessageMutex.Lock()
	defer fake.awaitMessageMutex.Unlock()
	fake.AwaitMessageStub = stub
}

func (fake *FakeController) AwaitMessageArgsForCall(i int) string {
	fake.awaitMessageMutex.RLock()
	defer fake.awaitMessageMutex.RUnlock()
	argsForCall := fake.awaitMessageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) AwaitMessageReturns(result1 controller.Message) {
	fake.awaitMessageMutex.Lock()
	defer fake.awaitMessageMutex.Unlock()
	fake.AwaitMessageStub = nil
	fake.awaitMessageReturns = struct {
		result1 controller.Message
	}{result1}
}

func (fake *FakeController) AwaitMessageReturnsOnCall(i int, result1 controller.Message) {
	fake.awaitMessageMutex.Lock()
	defer fake.awaitMessageMutex.Unlock()
	fake.AwaitMessageStub = nil
	if fake.awaitMessageReturnsOnCall == nil {
		fake.awaitMessageReturnsOnCall = make(map[int]struct {
			result1 controller.Message
		})
	}
	fake.awaitMessageReturnsOnCall[i] = struct {
		result1 controller.Message
	}{result1}
}

func (fake *FakeController) AwaitSignal(arg1 syscall.Signal) {
	fake.awaitSignalMutex.Lock()
	fake.awaitSignalArgsForCall = append(fake.awaitSignalArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("AwaitSignal", []interface{}{arg1})
	fake.awaitSignalMutex.Unlock()
	if fake.AwaitSignalStub != nil {
		fake.AwaitSignalStub(arg1)
	}
}

func (fake *FakeController) AwaitSignalCallCount() int {
	fake.awaitSignalMutex.RLock()
	defer fake.awaitSignalMutex.RUnlock()
	return len(fake.awaitSignalArgsForCall)
}

func (fake *FakeController) AwaitSignalCalls(stub func(syscall.Signal)) {
	fake.awaitSignalMutex.Lock()
	defer fake.awaitSignalMutex.Unlock()
	fake.AwaitSignalStub = stub
}

func (fake *FakeController) AwaitSignalArgsForCall(i int) syscall.Signal {
	fake.awaitSignalMutex.RLock()
	defer fake.awaitSignalMutex.RUnlock()
	argsForCall := fake.awaitSignalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) Checkpoints() []*state.State {
	fake.checkpointsMutex.Lock()
	ret, specificReturn := fake.checkpointsReturnsOnCall[len(fake.checkpointsArgsForCall)]
	fake.checkpointsArgsForCall = append(fake.checkpointsArgsForCall, struct {
	}{})
	fake.recordInvocation("Checkpoints", []interface{}{})
	fake.checkpointsMutex.Unlock()
	if fake.CheckpointsStub != nil {
		return fake.CheckpointsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.checkpointsReturns
	return fakeReturns.result1
}

func (fake *FakeController) CheckpointsCallCount() int {
	fake.checkpointsMutex.RLock()
	defer fake.checkpointsMutex.RUnlock()
	return len(fake.checkpointsArgsForCall)
}

func (fake *FakeController) CheckpointsCalls(stub func() []*state.State) {
	fake.checkpointsMutex.Lock()
	defer fake.checkpointsMutex.Unlock()
	fake.CheckpointsStub = stub
}

func (fake *FakeController) CheckpointsReturns(result1 []*state.State) {
	fake.checkpointsMutex.Lock()
	defer fake.checkpointsMutex.Unlock()
	fake.CheckpointsStub = nil
	fake.checkpointsReturns = struct {
		result1 []*state.State
	}{result1}
}

func (fake *FakeController) CheckpointsReturnsOnCall(i int, result1 []*state.State) {
	fake.checkpointsMutex.Lock()
	defer fake.checkpointsMutex.Unlock()
	fake.CheckpointsStub = nil
	if fake.checkpointsReturnsOnCall == nil {
		fake.checkpointsReturnsOnCall = make(map[int]struct {
			result1 []*state.State
		})
	}
	fake.checkpointsReturnsOnCall[i] = struct {
		result1 []*state.State
	}{result1}
}

func (fake *FakeController) ClearMemRefs() error {
	fake.clearMemRefsMutex.Lock()
	ret, specificReturn := fake.clearMemRefsReturnsOnCall[len(fake.clearMemRefsArgsForCall)]
	fake.clearMemRefsArgsForCall = append(fake.clearMemRefsArgsForCall, struct {
	}{})
	fake.recordInvocation("ClearMemRefs", []interface{}{})
	fake.clearMemRefsMutex.Unlock()
	if fake.ClearMemRefsStub != nil {
		return fake.ClearMemRefsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clearMemRefsReturns
	return fakeReturns.result1
}

func (fake *FakeController) ClearMemRefsCallCount() int {
	fake.clearMemRefsMutex.RLock()
	defer fake.clearMemRefsMutex.RUnlock()
	return len(fake.clearMemRefsArgsForCall)
}

func (fake *FakeController) ClearMemRefsCalls(stub func() error) {
	fake.clearMemRefsMutex.Lock()
	defer fake.clearMemRefsMutex.Unlock()
	fake.ClearMemRefsStub = stub
}

func (fake *FakeController) ClearMemRefsReturns(result1 error) {
	fake.clearMemRefsMutex.Lock()
	defer fake.clearMemRefsMutex.Unlock()
	fake.ClearMemRefsStub = nil
	fake.clearMemRefsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) ClearMemRefsReturnsOnCall(i int, result1 error) {
	fake.clearMemRefsMutex.Lock()
	defer fake.clearMemRefsMutex.Unlock()
	fake.ClearMemRefsStub = nil
	if fake.clearMemRefsReturnsOnCall == nil {
		fake.clearMemRefsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearMemRefsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Continue() {
	fake.continueMutex.Lock()
	fake.continueArgsForCall = append(fake.continueArgsForCall, struct {
	}{})
	fake.recordInvocation("Continue", []interface{}{})
	fake.continueMutex.Unlock()
	if fake.ContinueStub != nil {
		fake.ContinueStub()
	}
}

func (fake *FakeController) ContinueCallCount() int {
	fake.continueMutex.RLock()
	defer fake.continueMutex.RUnlock()
	return len(fake.continueArgsForCall)
}

func (fake *FakeController) ContinueCalls(stub func()) {
	fake.continueMutex.Lock()
	defer fake.continueMutex.Unlock()
	fake.ContinueStub = stub
}

func (fake *FakeController) ContinueTid(arg1 int, arg2 syscall.Signal) {
	fake.continueTidMutex.Lock()
	fake.continueTidArgsForCall = append(fake.continueTidArgsForCall, struct {
		arg1 int
		arg2 syscall.Signal
	}{arg1, arg2})
	fake.recordInvocation("ContinueTid", []interface{}{arg1, arg2})
	fake.continueTidMutex.Unlock()
	if fake.ContinueTidStub != nil {
		fake.ContinueTidStub(arg1, arg2)
	}
}

func (fake *FakeController) ContinueTidCallCount() int {
	fake.continueTidMutex.RLock()
	defer fake.continueTidMutex.RUnlock()
	return len(fake.continueTidArgsForCall)
}

func (fake *FakeController) ContinueTidCalls(stub func(int, syscall.Signal)) {
	fake.continueTidMutex.Lock()
	defer fake.continueTidMutex.Unlock()
	fake.ContinueTidStub = stub
}

func (fake *FakeController) ContinueTidArgsForCall(i int) (int, syscall.Signal) {
	fake.continueTidMutex.RLock()
	defer fake.continueTidMutex.RUnlock()
	argsForCall := fake.continueTidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) ContinueWith(arg1 syscall.Signal) {
	fake.continueWithMutex.Lock()
	fake.continueWithArgsForCall = append(fake.continueWithArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("ContinueWith", []interface{}{arg1})
	fake.continueWithMutex.Unlock()
	if fake.ContinueWithStub != nil {
		fake.ContinueWithStub(arg1)
	}
}

func (fake *FakeController) ContinueWithCallCount() int {
	fake.continueWithMutex.RLock()
	defer fake.continueWithMutex.RUnlock()
	return len(fake.continueWithArgsForCall)
}

func (fake *FakeController) ContinueWithCalls(stub func(syscall.Signal)) {
	fake.continueWithMutex.Lock()
	defer fake.continueWithMutex.Unlock()
	fake.ContinueWithStub = stub
}

func (fake *FakeController) ContinueWithArgsForCall(i int) syscall.Signal {
	fake.continueWithMutex.RLock()
	defer fake.continueWithMutex.RUnlock()
	argsForCall := fake.continueWithArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) Detach() error {
	fake.detachMutex.Lock()
	ret, specificReturn := fake.detachReturnsOnCall[len(fake.detachArgsForCall)]
	fake.detachArgsForCall = append(fake.detachArgsForCall, struct {
	}{})
	fake.recordInvocation("Detach", []interface{}{})
	fake.detachMutex.Unlock()
	if fake.DetachStub != nil {
		return fake.DetachStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.detachReturns
	return fakeReturns.result1
}

func (fake *FakeController) DetachCallCount() int {
	fake.detachMutex.RLock()
	defer fake.detachMutex.RUnlock()
	return len(fake.detachArgsForCall)
}

func (fake *FakeController) DetachCalls(stub func() error) {
	fake.detachMutex.Lock()
	defer fake.detachMutex.Unlock()
	fake.DetachStub = stub
}

func (fake *FakeController) DetachReturns(result1 error) {
	fake.detachMutex.Lock()
	defer fake.detachMutex.Unlock()
	fake.DetachStub = nil
	fake.detachReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) DetachReturnsOnCall(i int, result1 error) {
	fake.detachMutex.Lock()
	defer fake.detachMutex.Unlock()
	fake.DetachStub = nil
	if fake.detachReturnsOnCall == nil {
		fake.detachReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) End() error {
	fake.endMutex.Lock()
	ret, specificReturn := fake.endReturnsOnCall[len(fake.endArgsForCall)]
	fake.endArgsForCall = append(fake.endArgsForCall, struct {
	}{})
	fake.recordInvocation("End", []interface{}{})
	fake.endMutex.Unlock()
	if fake.EndStub != nil {
		return fake.EndStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.endReturns
	return fakeReturns.result1
}

func (fake *FakeController) EndCallCount() int {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	return len(fake.endArgsForCall)
}

func (fake *FakeController) EndCalls(stub func() error) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = stub
}

func (fake *FakeController) EndReturns(result1 error) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = nil
	fake.endReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) EndReturnsOnCall(i int, result1 error) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = nil
	if fake.endReturnsOnCall == nil {
		fake.endReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) InitialCheckpoint() (*state.State, error) {
	fake.initialCheckpointMutex.Lock()
	ret, specificReturn := fake.initialCheckpointReturnsOnCall[len(fake.initialCheckpointArgsForCall)]
	fake.initialCheckpointArgsForCall = append(fake.initialCheckpointArgsForCall, struct {
	}{})
	fake.recordInvocation("InitialCheckpoint", []interface{}{})
	fake.initialCheckpointMutex.Unlock()
	if fake.InitialCheckpointStub != nil {
		return fake.InitialCheckpointStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.initialCheckpointReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) InitialCheckpointCallCount() int {
	fake.initialCheckpointMutex.RLock()
	defer fake.initialCheckpointMutex.RUnlock()
	return len(fake.initialCheckpointArgsForCall)
}

func (fake *FakeController) InitialCheckpointCalls(stub func() (*state.State, error)) {
	fake.initialCheckpointMutex.Lock()
	defer fake.initialCheckpointMutex.Unlock()
	fake.InitialCheckpointStub = stub
}

func (fake *FakeController) InitialCheckpointReturns(result1 *state.State, result2 error) {
	fake.initialCheckpointMutex.Lock()
	defer fake.initialCheckpointMutex.Unlock()
	fake.InitialCheckpointStub = nil
	fake.initialCheckpointReturns = struct {
		result1 *state.State
		result2 error
	}{result1, result2}
}

func (fake *FakeController) InitialCheckpointReturnsOnCall(i int, result1 *state.State, result2 error) {
	fake.initialCheckpointMutex.Lock()
	defer fake.initialCheckpointMutex.Unlock()
	fake.InitialCheckpointStub = nil
	if fake.initialCheckpointReturnsOnCall == nil {
		fake.initialCheckpointReturnsOnCall = make(map[int]struct {
			result1 *state.State
			result2 error
		})
	}
	fake.initialCheckpointReturnsOnCall[i] = struct {
		result1 *state.State
		result2 error
	}{result1, result2}
}

func (fake *FakeController) PauseAtSignal(arg1 syscall.Signal) {
	fake.pauseAtSignalMutex.Lock()
	fake.pauseAtSignalArgsForCall = append(fake.pauseAtSignalArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("PauseAtSignal", []interface{}{arg1})
	fake.pauseAtSignalMutex.Unlock()
	if fake.PauseAtSignalStub != nil {
		fake.PauseAtSignalStub(arg1)
	}
}

func (fake *FakeController) PauseAtSignalCallCount() int {
	fake.pauseAtSignalMutex.RLock()
	defer fake.pauseAtSignalMutex.RUnlock()
	return len(fake.pauseAtSignalArgsForCall)
}

func (fake *FakeController) PauseAtSignalCalls(stub func(syscall.Signal)) {
	fake.pauseAtSignalMutex.Lock()
	defer fake.pauseAtSignalMutex.Unlock()
	fake.PauseAtSignalStub = stub
}

func (fake *FakeController) PauseAtSignalArgsForCall(i int) syscall.Signal {
	fake.pauseAtSignalMutex.RLock()
	defer fake.pauseAtSignalMutex.RUnlock()
	argsForCall := fake.pauseAtSignalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) Pid() int {
	fake.pidMutex.Lock()
	ret, specificReturn := fake.pidReturnsOnCall[len(fake.pidArgsForCall)]
	fake.pidArgsForCall = append(fake.pidArgsForCall, struct {
	}{})
	fake.recordInvocation("Pid", []interface{}{})
	fake.pidMutex.Unlock()
	if fake.PidStub != nil {
		return fake.PidStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pidReturns
	return fakeReturns.result1
}

func (fake *FakeController) PidCallCount() int {
	fake.pidMutex.RLock()
	defer fake.pidMutex.RUnlock()
	return len(fake.pidArgsForCall)
}

func (fake *FakeController) PidCalls(stub func() int) {
	fake.pidMutex.Lock()
	defer fake.pidMutex.Unlock()
	fake.PidStub = stub
}

func (fake *FakeController) PidReturns(result1 int) {
	fake.pidMutex.Lock()
	defer fake.pidMutex.Unlock()
	fake.PidStub = nil
	fake.pidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeController) PidReturnsOnCall(i int, result1 int) {
	fake.pidMutex.Lock()
	defer fake.pidMutex.Unlock()
	fake.PidStub = nil
	if fake.pidReturnsOnCall == nil {
		fake.pidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.pidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeController) Restore() error {
	fake.restoreMutex.Lock()
	ret, specificReturn := fake.restoreReturnsOnCall[len(fake.restoreArgsForCall)]
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct {
	}{})
	fake.recordInvocation("Restore", []interface{}{})
	fake.restoreMutex.Unlock()
	if fake.RestoreStub != nil {
		return fake.RestoreStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.restoreReturns
	return fakeReturns.result1
}

func (fake *FakeController) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeController) RestoreCalls(stub func() error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = stub
}

func (fake *FakeController) RestoreReturns(result1 error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	fake.restoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) RestoreReturnsOnCall(i int, result1 error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	if fake.restoreReturnsOnCall == nil {
		fake.restoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendFunction(arg1 string) error {
	fake.sendFunctionMutex.Lock()
	ret, specificReturn := fake.sendFunctionReturnsOnCall[len(fake.sendFunctionArgsForCall)]
	fake.sendFunctionArgsForCall = append(fake.sendFunctionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SendFunction", []interface{}{arg1})
	fake.sendFunctionMutex.Unlock()
	if fake.SendFunctionStub != nil {
		return fake.SendFunctionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendFunctionReturns
	return fakeReturns.result1
}

func (fake *FakeController) SendFunctionCallCount() int {
	fake.sendFunctionMutex.RLock()
	defer fake.sendFunctionMutex.RUnlock()
	return len(fake.sendFunctionArgsForCall)
}

func (fake *FakeController) SendFunctionCalls(stub func(string) error) {
	fake.sendFunctionMutex.Lock()
	defer fake.sendFunctionMutex.Unlock()
	fake.SendFunctionStub = stub
}

func (fake *FakeController) SendFunctionArgsForCall(i int) string {
	fake.sendFunctionMutex.RLock()
	defer fake.sendFunctionMutex.RUnlock()
	argsForCall := fake.sendFunctionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SendFunctionReturns(result1 error) {
	fake.sendFunctionMutex.Lock()
	defer fake.sendFunctionMutex.Unlock()
	fake.SendFunctionStub = nil
	fake.sendFunctionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendFunctionReturnsOnCall(i int, result1 error) {
	fake.sendFunctionMutex.Lock()
	defer fake.sendFunctionMutex.Unlock()
	fake.SendFunctionStub = nil
	if fake.sendFunctionReturnsOnCall == nil {
		fake.sendFunctionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendFunctionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendMessage(arg1 string, arg2 interface{}) error {
	fake.sendMessageMutex.Lock()
	ret, specificReturn := fake.sendMessageReturnsOnCall[len(fake.sendMessageArgsForCall)]
	fake.sendMessageArgsForCall = append(fake.sendMessageArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("SendMessage", []interface{}{arg1, arg2})
	fake.sendMessageMutex.Unlock()
	if fake.SendMessageStub != nil {
		return fake.SendMessageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendMessageReturns
	return fakeReturns.result1
}

func (fake *FakeController) SendMessageCallCount() int {
	fake.sendMessageMutex.RLock()
	defer fake.sendMessageMutex.RUnlock()
	return len(fake.sendMessageArgsForCall)
}

func (fake *FakeController) SendMessageCalls(stub func(string, interface{}) error) {
	fake.sendMessageMutex.Lock()
	defer fake.sendMessageMutex.Unlock()
	fake.SendMessageStub = stub
}

func (fake *FakeController) SendMessageArgsForCall(i int) (string, interface{}) {
	fake.sendMessageMutex.RLock()
	defer fake.sendMessageMutex.RUnlock()
	argsForCall := fake.sendMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) SendMessageReturns(result1 error) {
	fake.sendMessageMutex.Lock()
	defer fake.sendMessageMutex.Unlock()
	fake.SendMessageStub = nil
	fake.sendMessageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendMessageReturnsOnCall(i int, result1 error) {
	fake.sendMessageMutex.Lock()
	defer fake.sendMessageMutex.Unlock()
	fake.SendMessageStub = nil
	if fake.sendMessageReturnsOnCall == nil {
		fake.sendMessageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendMessageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendRequest(arg1 interface{}) (interface{}, error) {
	fake.sendRequestMutex.Lock()
	ret, specificReturn := fake.sendRequestReturnsOnCall[len(fake.sendRequestArgsForCall)]
	fake.sendRequestArgsForCall = append(fake.sendRequestArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("SendRequest", []interface{}{arg1})
	fake.sendRequestMutex.Unlock()
	if fake.SendRequestStub != nil {
		return fake.SendRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.sendRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) SendRequestCallCount() int {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	return len(fake.sendRequestArgsForCall)
}

func (fake *FakeController) SendRequestCalls(stub func(interface{}) (interface{}, error)) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = stub
}

func (fake *FakeController) SendRequestArgsForCall(i int) interface{} {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	argsForCall := fake.sendRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SendRequestReturns(result1 interface{}, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	fake.sendRequestReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeController) SendRequestReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	if fake.sendRequestReturnsOnCall == nil {
		fake.sendRequestReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.sendRequestReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeController) SendSignal(arg1 syscall.Signal) error {
	fake.sendSignalMutex.Lock()
	ret, specificReturn := fake.sendSignalReturnsOnCall[len(fake.sendSignalArgsForCall)]
	fake.sendSignalArgsForCall = append(fake.sendSignalArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("SendSignal", []interface{}{arg1})
	fake.sendSignalMutex.Unlock()
	if fake.SendSignalStub != nil {
		return fake.SendSignalStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendSignalReturns
	return fakeReturns.result1
}

func (fake *FakeController) SendSignalCallCount() int {
	fake.sendSignalMutex.RLock()
	defer fake.sendSignalMutex.RUnlock()
	return len(fake.sendSignalArgsForCall)
}

func (fake *FakeController) SendSignalCalls(stub func(syscall.Signal) error) {
	fake.sendSignalMutex.Lock()
	defer fake.sendSignalMutex.Unlock()
	fake.SendSignalStub = stub
}

func (fake *FakeController) SendSignalArgsForCall(i int) syscall.Signal {
	fake.sendSignalMutex.RLock()
	defer fake.sendSignalMutex.RUnlock()
	argsForCall := fake.sendSignalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SendSignalReturns(result1 error) {
	fake.sendSignalMutex.Lock()
	defer fake.sendSignalMutex.Unlock()
	fake.SendSignalStub = nil
	fake.sendSignalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendSignalReturnsOnCall(i int, result1 error) {
	fake.sendSignalMutex.Lock()
	defer fake.sendSignalMutex.Unlock()
	fake.SendSignalStub = nil
	if fake.sendSignalReturnsOnCall == nil {
		fake.sendSignalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendSignalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendSignalCont(arg1 syscall.Signal) error {
	fake.sendSignalContMutex.Lock()
	ret, specificReturn := fake.sendSignalContReturnsOnCall[len(fake.sendSignalContArgsForCall)]
	fake.sendSignalContArgsForCall = append(fake.sendSignalContArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("SendSignalCont", []interface{}{arg1})
	fake.sendSignalContMutex.Unlock()
	if fake.SendSignalContStub != nil {
		return fake.SendSignalContStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendSignalContReturns
	return fakeReturns.result1
}

func (fake *FakeController) SendSignalContCallCount() int {
	fake.sendSignalContMutex.RLock()
	defer fake.sendSignalContMutex.RUnlock()
	return len(fake.sendSignalContArgsForCall)
}

func (fake *FakeController) SendSignalContCalls(stub func(syscall.Signal) error) {
	fake.sendSignalContMutex.Lock()
	defer fake.sendSignalContMutex.Unlock()
	fake.SendSignalContStub = stub
}

func (fake *FakeController) SendSignalContArgsForCall(i int) syscall.Signal {
	fake.sendSignalContMutex.RLock()
	defer fake.sendSignalContMutex.RUnlock()
	argsForCall := fake.sendSignalContArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SendSignalContReturns(result1 error) {
	fake.sendSignalContMutex.Lock()
	defer fake.sendSignalContMutex.Unlock()
	fake.SendSignalContStub = nil
	fake.sendSignalContReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendSignalContReturnsOnCall(i int, result1 error) {
	fake.sendSignalContMutex.Lock()
	defer fake.sendSignalContMutex.Unlock()
	fake.SendSignalContStub = nil
	if fake.sendSignalContReturnsOnCall == nil {
		fake.sendSignalContReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendSignalContReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SetPid(arg1 int) {
	fake.setPidMutex.Lock()
	fake.setPidArgsForCall = append(fake.setPidArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("SetPid", []interface{}{arg1})
	fake.setPidMutex.Unlock()
	if fake.SetPidStub != nil {
		fake.SetPidStub(arg1)
	}
}

func (fake *FakeController) SetPidCallCount() int {
	fake.setPidMutex.RLock()
	defer fake.setPidMutex.RUnlock()
	return len(fake.setPidArgsForCall)
}

func (fake *FakeController) SetPidCalls(stub func(int)) {
	fake.setPidMutex.Lock()
	defer fake.setPidMutex.Unlock()
	fake.SetPidStub = stub
}

func (fake *FakeController) SetPidArgsForCall(i int) int {
	fake.setPidMutex.RLock()
	defer fake.setPidMutex.RUnlock()
	argsForCall := fake.setPidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SetRegs(arg1 *state.State) error {
	fake.setRegsMutex.Lock()
	ret, specificReturn := fake.setRegsReturnsOnCall[len(fake.setRegsArgsForCall)]
	fake.setRegsArgsForCall = append(fake.setRegsArgsForCall, struct {
		arg1 *state.State
	}{arg1})
	fake.recordInvocation("SetRegs", []interface{}{arg1})
	fake.setRegsMutex.Unlock()
	if fake.SetRegsStub != nil {
		return fake.SetRegsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setRegsReturns
	return fakeReturns.result1
}

func (fake *FakeController) SetRegsCallCount() int {
	fake.setRegsMutex.RLock()
	defer fake.setRegsMutex.RUnlock()
	return len(fake.setRegsArgsForCall)
}

func (fake *FakeController) SetRegsCalls(stub func(*state.State) error) {
	fake.setRegsMutex.Lock()
	defer fake.setRegsMutex.Unlock()
	fake.SetRegsStub = stub
}

func (fake *FakeController) SetRegsArgsForCall(i int) *state.State {
	fake.setRegsMutex.RLock()
	defer fake.setRegsMutex.RUnlock()
	argsForCall := fake.setRegsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SetRegsReturns(result1 error) {
	fake.setRegsMutex.Lock()
	defer fake.setRegsMutex.Unlock()
	fake.SetRegsStub = nil
	fake.setRegsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SetRegsReturnsOnCall(i int, result1 error) {
	fake.setRegsMutex.Lock()
	defer fake.setRegsMutex.Unlock()
	fake.SetRegsStub = nil
	if fake.setRegsReturnsOnCall == nil {
		fake.setRegsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setRegsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SetStreams(arg1 *io.PipeWriter, arg2 *io.PipeReader, arg3 *io.PipeReader) {
	fake.setStreamsMutex.Lock()
	fake.setStreamsArgsForCall = append(fake.setStreamsArgsForCall, struct {
		arg1 *io.PipeWriter
		arg2 *io.PipeReader
		arg3 *io.PipeReader
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetStreams", []interface{}{arg1, arg2, arg3})
	fake.setStreamsMutex.Unlock()
	if fake.SetStreamsStub != nil {
		fake.SetStreamsStub(arg1, arg2, arg3)
	}
}

func (fake *FakeController) SetStreamsCallCount() int {
	fake.setStreamsMutex.RLock()
	defer fake.setStreamsMutex.RUnlock()
	return len(fake.setStreamsArgsForCall)
}

func (fake *FakeController) SetStreamsCalls(stub func(*io.PipeWriter, *io.PipeReader, *io.PipeReader)) {
	fake.setStreamsMutex.Lock()
	defer fake.setStreamsMutex.Unlock()
	fake.SetStreamsStub = stub
}

func (fake *FakeController) SetStreamsArgsForCall(i int) (*io.PipeWriter, *io.PipeReader, *io.PipeReader) {
	fake.setStreamsMutex.RLock()
	defer fake.setStreamsMutex.RUnlock()
	argsForCall := fake.setStreamsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeController) State() (*state.State, error) {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if fake.StateStub != nil {
		return fake.StateStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.stateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeController) StateCalls(stub func() (*state.State, error)) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *FakeController) StateReturns(result1 *state.State, result2 error) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 *state.State
		result2 error
	}{result1, result2}
}

func (fake *FakeController) StateReturnsOnCall(i int, result1 *state.State, result2 error) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 *state.State
			result2 error
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 *state.State
		result2 error
	}{result1, result2}
}

func (fake *FakeController) Stop() error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
	}{})
	fake.recordInvocation("Stop", []interface{}{})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stopReturns
	return fakeReturns.result1
}

func (fake *FakeController) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeController) StopCalls(stub func() error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeController) StopReturns(result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) StopReturnsOnCall(i int, result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Streams() (*io.PipeWriter, *io.PipeReader, *io.PipeReader) {
	fake.streamsMutex.Lock()
	ret, specificReturn := fake.streamsReturnsOnCall[len(fake.streamsArgsForCall)]
	fake.streamsArgsForCall = append(fake.streamsArgsForCall, struct {
	}{})
	fake.recordInvocation("Streams", []interface{}{})
	fake.streamsMutex.Unlock()
	if fake.StreamsStub != nil {
		return fake.StreamsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.streamsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeController) StreamsCallCount() int {
	fake.streamsMutex.RLock()
	defer fake.streamsMutex.RUnlock()
	return len(fake.streamsArgsForCall)
}

func (fake *FakeController) StreamsCalls(stub func() (*io.PipeWriter, *io.PipeReader, *io.PipeReader)) {
	fake.streamsMutex.Lock()
	defer fake.streamsMutex.Unlock()
	fake.StreamsStub = stub
}

func (fake *FakeController) StreamsReturns(result1 *io.PipeWriter, result2 *io.PipeReader, result3 *io.PipeReader) {
	fake.streamsMutex.Lock()
	defer fake.streamsMutex.Unlock()
	fake.StreamsStub = nil
	fake.streamsReturns = struct {
		result1 *io.PipeWriter
		result2 *io.PipeReader
		result3 *io.PipeReader
	}{result1, result2, result3}
}

func (fake *FakeController) StreamsReturnsOnCall(i int, result1 *io.PipeWriter, result2 *io.PipeReader, result3 *io.PipeReader) {
	fake.streamsMutex.Lock()
	defer fake.streamsMutex.Unlock()
	fake.StreamsStub = nil
	if fake.streamsReturnsOnCall == nil {
		fake.streamsReturnsOnCall = make(map[int]struct {
			result1 *io.PipeWriter
			result2 *io.PipeReader
			result3 *io.PipeReader
		})
	}
	fake.streamsReturnsOnCall[i] = struct {
		result1 *io.PipeWriter
		result2 *io.PipeReader
		result3 *io.PipeReader
	}{result1, result2, result3}
}

func (fake *FakeController) TakeCheckpoint() error {
	fake.takeCheckpointMutex.Lock()
	ret, specificReturn := fake.takeCheckpointReturnsOnCall[len(fake.takeCheckpointArgsForCall)]
	fake.takeCheckpointArgsForCall = append(fake.takeCheckpointArgsForCall, struct {
	}{})
	fake.recordInvocation("TakeCheckpoint", []interface{}{})
	fake.takeCheckpointMutex.Unlock()
	if fake.TakeCheckpointStub != nil {
		return fake.TakeCheckpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.takeCheckpointReturns
	return fakeReturns.result1
}

func (fake *FakeController) TakeCheckpointCallCount() int {
	fake.takeCheckpointMutex.RLock()
	defer fake.takeCheckpointMutex.RUnlock()
	return len(fake.takeCheckpointArgsForCall)
}

func (fake *FakeController) TakeCheckpointCalls(stub func() error) {
	fake.takeCheckpointMutex.Lock()
	defer fake.takeCheckpointMutex.Unlock()
	fake.TakeCheckpointStub = stub
}

func (fake *FakeController) TakeCheckpointReturns(result1 error) {
	fake.takeCheckpointMutex.Lock()
	defer fake.takeCheckpointMutex.Unlock()
	fake.TakeCheckpointStub = nil
	fake.takeCheckpointReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) TakeCheckpointReturnsOnCall(i int, result1 error) {
	fake.takeCheckpointMutex.Lock()
	defer fake.takeCheckpointMutex.Unlock()
	fake.TakeCheckpointStub = nil
	if fake.takeCheckpointReturnsOnCall == nil {
		fake.takeCheckpointReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.takeCheckpointReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) WithSyscallTrace(arg1 io.Writer) {
	fake.withSyscallTraceMutex.Lock()
	fake.withSyscallTraceArgsForCall = append(fake.withSyscallTraceArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.recordInvocation("WithSyscallTrace", []interface{}{arg1})
	fake.withSyscallTraceMutex.Unlock()
	if fake.WithSyscallTraceStub != nil {
		fake.WithSyscallTraceStub(arg1)
	}
}

func (fake *FakeController) WithSyscallTraceCallCount() int {
	fake.withSyscallTraceMutex.RLock()
	defer fake.withSyscallTraceMutex.RUnlock()
	return len(fake.withSyscallTraceArgsForCall)
}

func (fake *FakeController) WithSyscallTraceCalls(stub func(io.Writer)) {
	fake.withSyscallTraceMutex.Lock()
	defer fake.withSyscallTraceMutex.Unlock()
	fake.WithSyscallTraceStub = stub
}

func (fake *FakeController) WithSyscallTraceArgsForCall(i int) io.Writer {
	fake.withSyscallTraceMutex.RLock()
	defer fake.withSyscallTraceMutex.RUnlock()
	argsForCall := fake.withSyscallTraceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activateMutex.RLock()
	defer fake.activateMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.awaitMessageMutex.RLock()
	defer fake.awaitMessageMutex.RUnlock()
	fake.awaitSignalMutex.RLock()
	defer fake.awaitSignalMutex.RUnlock()
	fake.checkpointsMutex.RLock()
	defer fake.checkpointsMutex.RUnlock()
	fake.clearMemRefsMutex.RLock()
	defer fake.clearMemRefsMutex.RUnlock()
	fake.continueMutex.RLock()
	defer fake.continueMutex.RUnlock()
	fake.continueTidMutex.RLock()
	defer fake.continueTidMutex.RUnlock()
	fake.continueWithMutex.RLock()
	defer fake.continueWithMutex.RUnlock()
	fake.detachMutex.RLock()
	defer fake.detachMutex.RUnlock()
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	fake.initialCheckpointMutex.RLock()
	defer fake.initialCheckpointMutex.RUnlock()
	fake.pauseAtSignalMutex.RLock()
	defer fake.pauseAtSignalMutex.RUnlock()
	fake.pidMutex.RLock()
	defer fake.pidMutex.RUnlock()
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	fake.sendFunctionMutex.RLock()
	defer fake.sendFunctionMutex.RUnlock()
	fake.sendMessageMutex.RLock()
	defer fake.sendMessageMutex.RUnlock()
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	fake.sendSignalMutex.RLock()
	defer fake.sendSignalMutex.RUnlock()
	fake.sendSignalContMutex.RLock()
	defer fake.sendSignalContMutex.RUnlock()
	fake.setPidMutex.RLock()
	defer fake.setPidMutex.RUnlock()
	fake.setRegsMutex.RLock()
	defer fake.setRegsMutex.RUnlock()
	fake.setStreamsMutex.RLock()
	defer fake.setStreamsMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.streamsMutex.RLock()
	defer fake.streamsMutex.RUnlock()
	fake.takeCheckpointMutex.RLock()
	defer fake.takeCheckpointMutex.RUnlock()
	fake.withSyscallTraceMutex.RLock()
	defer fake.withSyscallTraceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeController) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ controller.Controller = new(FakeController)
