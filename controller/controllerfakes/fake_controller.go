// Code generated by counterfeiter. DO NOT EDIT.
package controllerfakes

import (
	"io"
	"sync"
	"syscall"

	"github.com/ostenbom/refunction/controller"
	"github.com/ostenbom/refunction/state"
)

type FakeController struct {
	ActivateStub        func() error
	activateMutex       sync.RWMutex
	activateArgsForCall []struct {
	}
	activateReturns struct {
		result1 error
	}
	activateReturnsOnCall map[int]struct {
		result1 error
	}
	AttachStub        func() error
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
	}
	attachReturns struct {
		result1 error
	}
	attachReturnsOnCall map[int]struct {
		result1 error
	}
	AwaitMessageStub        func(string) controller.Message
	awaitMessageMutex       sync.RWMutex
	awaitMessageArgsForCall []struct {
		arg1 string
	}
	awaitMessageReturns struct {
		result1 controller.Message
	}
	awaitMessageReturnsOnCall map[int]struct {
		result1 controller.Message
	}
	AwaitSignalStub        func(syscall.Signal)
	awaitSignalMutex       sync.RWMutex
	awaitSignalArgsForCall []struct {
		arg1 syscall.Signal
	}
	ClearMemRefsStub        func() error
	clearMemRefsMutex       sync.RWMutex
	clearMemRefsArgsForCall []struct {
	}
	clearMemRefsReturns struct {
		result1 error
	}
	clearMemRefsReturnsOnCall map[int]struct {
		result1 error
	}
	ContinueStub        func()
	continueMutex       sync.RWMutex
	continueArgsForCall []struct {
	}
	ContinueTidStub        func(int, syscall.Signal)
	continueTidMutex       sync.RWMutex
	continueTidArgsForCall []struct {
		arg1 int
		arg2 syscall.Signal
	}
	ContinueWithStub        func(syscall.Signal)
	continueWithMutex       sync.RWMutex
	continueWithArgsForCall []struct {
		arg1 syscall.Signal
	}
	DetachStub        func() error
	detachMutex       sync.RWMutex
	detachArgsForCall []struct {
	}
	detachReturns struct {
		result1 error
	}
	detachReturnsOnCall map[int]struct {
		result1 error
	}
	EndStub        func() error
	endMutex       sync.RWMutex
	endArgsForCall []struct {
	}
	endReturns struct {
		result1 error
	}
	endReturnsOnCall map[int]struct {
		result1 error
	}
	GetCheckpointsStub        func() []*state.State
	getCheckpointsMutex       sync.RWMutex
	getCheckpointsArgsForCall []struct {
	}
	getCheckpointsReturns struct {
		result1 []*state.State
	}
	getCheckpointsReturnsOnCall map[int]struct {
		result1 []*state.State
	}
	GetInitialCheckpointStub        func() (*state.State, error)
	getInitialCheckpointMutex       sync.RWMutex
	getInitialCheckpointArgsForCall []struct {
	}
	getInitialCheckpointReturns struct {
		result1 *state.State
		result2 error
	}
	getInitialCheckpointReturnsOnCall map[int]struct {
		result1 *state.State
		result2 error
	}
	GetStateStub        func() (*state.State, error)
	getStateMutex       sync.RWMutex
	getStateArgsForCall []struct {
	}
	getStateReturns struct {
		result1 *state.State
		result2 error
	}
	getStateReturnsOnCall map[int]struct {
		result1 *state.State
		result2 error
	}
	PauseAtSignalStub        func(syscall.Signal)
	pauseAtSignalMutex       sync.RWMutex
	pauseAtSignalArgsForCall []struct {
		arg1 syscall.Signal
	}
	RestoreStub        func() error
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct {
	}
	restoreReturns struct {
		result1 error
	}
	restoreReturnsOnCall map[int]struct {
		result1 error
	}
	SendFunctionStub        func(string) error
	sendFunctionMutex       sync.RWMutex
	sendFunctionArgsForCall []struct {
		arg1 string
	}
	sendFunctionReturns struct {
		result1 error
	}
	sendFunctionReturnsOnCall map[int]struct {
		result1 error
	}
	SendMessageStub        func(string, interface{}) error
	sendMessageMutex       sync.RWMutex
	sendMessageArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	sendMessageReturns struct {
		result1 error
	}
	sendMessageReturnsOnCall map[int]struct {
		result1 error
	}
	SendRequestStub        func(interface{}) (interface{}, error)
	sendRequestMutex       sync.RWMutex
	sendRequestArgsForCall []struct {
		arg1 interface{}
	}
	sendRequestReturns struct {
		result1 interface{}
		result2 error
	}
	sendRequestReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	SendSignalStub        func(syscall.Signal) error
	sendSignalMutex       sync.RWMutex
	sendSignalArgsForCall []struct {
		arg1 syscall.Signal
	}
	sendSignalReturns struct {
		result1 error
	}
	sendSignalReturnsOnCall map[int]struct {
		result1 error
	}
	SendSignalContStub        func(syscall.Signal) error
	sendSignalContMutex       sync.RWMutex
	sendSignalContArgsForCall []struct {
		arg1 syscall.Signal
	}
	sendSignalContReturns struct {
		result1 error
	}
	sendSignalContReturnsOnCall map[int]struct {
		result1 error
	}
	SetPidStub        func(int)
	setPidMutex       sync.RWMutex
	setPidArgsForCall []struct {
		arg1 int
	}
	SetRegsStub        func(*state.State) error
	setRegsMutex       sync.RWMutex
	setRegsArgsForCall []struct {
		arg1 *state.State
	}
	setRegsReturns struct {
		result1 error
	}
	setRegsReturnsOnCall map[int]struct {
		result1 error
	}
	SetStreamsStub        func(*io.PipeWriter, *io.PipeReader, *io.PipeReader)
	setStreamsMutex       sync.RWMutex
	setStreamsArgsForCall []struct {
		arg1 *io.PipeWriter
		arg2 *io.PipeReader
		arg3 *io.PipeReader
	}
	StopStub        func() error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	TakeCheckpointStub        func() error
	takeCheckpointMutex       sync.RWMutex
	takeCheckpointArgsForCall []struct {
	}
	takeCheckpointReturns struct {
		result1 error
	}
	takeCheckpointReturnsOnCall map[int]struct {
		result1 error
	}
	WithSyscallTraceStub        func(io.Writer)
	withSyscallTraceMutex       sync.RWMutex
	withSyscallTraceArgsForCall []struct {
		arg1 io.Writer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeController) Activate() error {
	fake.activateMutex.Lock()
	ret, specificReturn := fake.activateReturnsOnCall[len(fake.activateArgsForCall)]
	fake.activateArgsForCall = append(fake.activateArgsForCall, struct {
	}{})
	fake.recordInvocation("Activate", []interface{}{})
	fake.activateMutex.Unlock()
	if fake.ActivateStub != nil {
		return fake.ActivateStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.activateReturns
	return fakeReturns.result1
}

func (fake *FakeController) ActivateCallCount() int {
	fake.activateMutex.RLock()
	defer fake.activateMutex.RUnlock()
	return len(fake.activateArgsForCall)
}

func (fake *FakeController) ActivateCalls(stub func() error) {
	fake.activateMutex.Lock()
	defer fake.activateMutex.Unlock()
	fake.ActivateStub = stub
}

func (fake *FakeController) ActivateReturns(result1 error) {
	fake.activateMutex.Lock()
	defer fake.activateMutex.Unlock()
	fake.ActivateStub = nil
	fake.activateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) ActivateReturnsOnCall(i int, result1 error) {
	fake.activateMutex.Lock()
	defer fake.activateMutex.Unlock()
	fake.ActivateStub = nil
	if fake.activateReturnsOnCall == nil {
		fake.activateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.activateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Attach() error {
	fake.attachMutex.Lock()
	ret, specificReturn := fake.attachReturnsOnCall[len(fake.attachArgsForCall)]
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
	}{})
	fake.recordInvocation("Attach", []interface{}{})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachReturns
	return fakeReturns.result1
}

func (fake *FakeController) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeController) AttachCalls(stub func() error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = stub
}

func (fake *FakeController) AttachReturns(result1 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AttachReturnsOnCall(i int, result1 error) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = nil
	if fake.attachReturnsOnCall == nil {
		fake.attachReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AwaitMessage(arg1 string) controller.Message {
	fake.awaitMessageMutex.Lock()
	ret, specificReturn := fake.awaitMessageReturnsOnCall[len(fake.awaitMessageArgsForCall)]
	fake.awaitMessageArgsForCall = append(fake.awaitMessageArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("AwaitMessage", []interface{}{arg1})
	fake.awaitMessageMutex.Unlock()
	if fake.AwaitMessageStub != nil {
		return fake.AwaitMessageStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.awaitMessageReturns
	return fakeReturns.result1
}

func (fake *FakeController) AwaitMessageCallCount() int {
	fake.awaitMessageMutex.RLock()
	defer fake.awaitMessageMutex.RUnlock()
	return len(fake.awaitMessageArgsForCall)
}

func (fake *FakeController) AwaitMessageCalls(stub func(string) controller.Message) {
	fake.awaitMessageMutex.Lock()
	defer fake.awaitMessageMutex.Unlock()
	fake.AwaitMessageStub = stub
}

func (fake *FakeController) AwaitMessageArgsForCall(i int) string {
	fake.awaitMessageMutex.RLock()
	defer fake.awaitMessageMutex.RUnlock()
	argsForCall := fake.awaitMessageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) AwaitMessageReturns(result1 controller.Message) {
	fake.awaitMessageMutex.Lock()
	defer fake.awaitMessageMutex.Unlock()
	fake.AwaitMessageStub = nil
	fake.awaitMessageReturns = struct {
		result1 controller.Message
	}{result1}
}

func (fake *FakeController) AwaitMessageReturnsOnCall(i int, result1 controller.Message) {
	fake.awaitMessageMutex.Lock()
	defer fake.awaitMessageMutex.Unlock()
	fake.AwaitMessageStub = nil
	if fake.awaitMessageReturnsOnCall == nil {
		fake.awaitMessageReturnsOnCall = make(map[int]struct {
			result1 controller.Message
		})
	}
	fake.awaitMessageReturnsOnCall[i] = struct {
		result1 controller.Message
	}{result1}
}

func (fake *FakeController) AwaitSignal(arg1 syscall.Signal) {
	fake.awaitSignalMutex.Lock()
	fake.awaitSignalArgsForCall = append(fake.awaitSignalArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("AwaitSignal", []interface{}{arg1})
	fake.awaitSignalMutex.Unlock()
	if fake.AwaitSignalStub != nil {
		fake.AwaitSignalStub(arg1)
	}
}

func (fake *FakeController) AwaitSignalCallCount() int {
	fake.awaitSignalMutex.RLock()
	defer fake.awaitSignalMutex.RUnlock()
	return len(fake.awaitSignalArgsForCall)
}

func (fake *FakeController) AwaitSignalCalls(stub func(syscall.Signal)) {
	fake.awaitSignalMutex.Lock()
	defer fake.awaitSignalMutex.Unlock()
	fake.AwaitSignalStub = stub
}

func (fake *FakeController) AwaitSignalArgsForCall(i int) syscall.Signal {
	fake.awaitSignalMutex.RLock()
	defer fake.awaitSignalMutex.RUnlock()
	argsForCall := fake.awaitSignalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) ClearMemRefs() error {
	fake.clearMemRefsMutex.Lock()
	ret, specificReturn := fake.clearMemRefsReturnsOnCall[len(fake.clearMemRefsArgsForCall)]
	fake.clearMemRefsArgsForCall = append(fake.clearMemRefsArgsForCall, struct {
	}{})
	fake.recordInvocation("ClearMemRefs", []interface{}{})
	fake.clearMemRefsMutex.Unlock()
	if fake.ClearMemRefsStub != nil {
		return fake.ClearMemRefsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clearMemRefsReturns
	return fakeReturns.result1
}

func (fake *FakeController) ClearMemRefsCallCount() int {
	fake.clearMemRefsMutex.RLock()
	defer fake.clearMemRefsMutex.RUnlock()
	return len(fake.clearMemRefsArgsForCall)
}

func (fake *FakeController) ClearMemRefsCalls(stub func() error) {
	fake.clearMemRefsMutex.Lock()
	defer fake.clearMemRefsMutex.Unlock()
	fake.ClearMemRefsStub = stub
}

func (fake *FakeController) ClearMemRefsReturns(result1 error) {
	fake.clearMemRefsMutex.Lock()
	defer fake.clearMemRefsMutex.Unlock()
	fake.ClearMemRefsStub = nil
	fake.clearMemRefsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) ClearMemRefsReturnsOnCall(i int, result1 error) {
	fake.clearMemRefsMutex.Lock()
	defer fake.clearMemRefsMutex.Unlock()
	fake.ClearMemRefsStub = nil
	if fake.clearMemRefsReturnsOnCall == nil {
		fake.clearMemRefsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearMemRefsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Continue() {
	fake.continueMutex.Lock()
	fake.continueArgsForCall = append(fake.continueArgsForCall, struct {
	}{})
	fake.recordInvocation("Continue", []interface{}{})
	fake.continueMutex.Unlock()
	if fake.ContinueStub != nil {
		fake.ContinueStub()
	}
}

func (fake *FakeController) ContinueCallCount() int {
	fake.continueMutex.RLock()
	defer fake.continueMutex.RUnlock()
	return len(fake.continueArgsForCall)
}

func (fake *FakeController) ContinueCalls(stub func()) {
	fake.continueMutex.Lock()
	defer fake.continueMutex.Unlock()
	fake.ContinueStub = stub
}

func (fake *FakeController) ContinueTid(arg1 int, arg2 syscall.Signal) {
	fake.continueTidMutex.Lock()
	fake.continueTidArgsForCall = append(fake.continueTidArgsForCall, struct {
		arg1 int
		arg2 syscall.Signal
	}{arg1, arg2})
	fake.recordInvocation("ContinueTid", []interface{}{arg1, arg2})
	fake.continueTidMutex.Unlock()
	if fake.ContinueTidStub != nil {
		fake.ContinueTidStub(arg1, arg2)
	}
}

func (fake *FakeController) ContinueTidCallCount() int {
	fake.continueTidMutex.RLock()
	defer fake.continueTidMutex.RUnlock()
	return len(fake.continueTidArgsForCall)
}

func (fake *FakeController) ContinueTidCalls(stub func(int, syscall.Signal)) {
	fake.continueTidMutex.Lock()
	defer fake.continueTidMutex.Unlock()
	fake.ContinueTidStub = stub
}

func (fake *FakeController) ContinueTidArgsForCall(i int) (int, syscall.Signal) {
	fake.continueTidMutex.RLock()
	defer fake.continueTidMutex.RUnlock()
	argsForCall := fake.continueTidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) ContinueWith(arg1 syscall.Signal) {
	fake.continueWithMutex.Lock()
	fake.continueWithArgsForCall = append(fake.continueWithArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("ContinueWith", []interface{}{arg1})
	fake.continueWithMutex.Unlock()
	if fake.ContinueWithStub != nil {
		fake.ContinueWithStub(arg1)
	}
}

func (fake *FakeController) ContinueWithCallCount() int {
	fake.continueWithMutex.RLock()
	defer fake.continueWithMutex.RUnlock()
	return len(fake.continueWithArgsForCall)
}

func (fake *FakeController) ContinueWithCalls(stub func(syscall.Signal)) {
	fake.continueWithMutex.Lock()
	defer fake.continueWithMutex.Unlock()
	fake.ContinueWithStub = stub
}

func (fake *FakeController) ContinueWithArgsForCall(i int) syscall.Signal {
	fake.continueWithMutex.RLock()
	defer fake.continueWithMutex.RUnlock()
	argsForCall := fake.continueWithArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) Detach() error {
	fake.detachMutex.Lock()
	ret, specificReturn := fake.detachReturnsOnCall[len(fake.detachArgsForCall)]
	fake.detachArgsForCall = append(fake.detachArgsForCall, struct {
	}{})
	fake.recordInvocation("Detach", []interface{}{})
	fake.detachMutex.Unlock()
	if fake.DetachStub != nil {
		return fake.DetachStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.detachReturns
	return fakeReturns.result1
}

func (fake *FakeController) DetachCallCount() int {
	fake.detachMutex.RLock()
	defer fake.detachMutex.RUnlock()
	return len(fake.detachArgsForCall)
}

func (fake *FakeController) DetachCalls(stub func() error) {
	fake.detachMutex.Lock()
	defer fake.detachMutex.Unlock()
	fake.DetachStub = stub
}

func (fake *FakeController) DetachReturns(result1 error) {
	fake.detachMutex.Lock()
	defer fake.detachMutex.Unlock()
	fake.DetachStub = nil
	fake.detachReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) DetachReturnsOnCall(i int, result1 error) {
	fake.detachMutex.Lock()
	defer fake.detachMutex.Unlock()
	fake.DetachStub = nil
	if fake.detachReturnsOnCall == nil {
		fake.detachReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) End() error {
	fake.endMutex.Lock()
	ret, specificReturn := fake.endReturnsOnCall[len(fake.endArgsForCall)]
	fake.endArgsForCall = append(fake.endArgsForCall, struct {
	}{})
	fake.recordInvocation("End", []interface{}{})
	fake.endMutex.Unlock()
	if fake.EndStub != nil {
		return fake.EndStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.endReturns
	return fakeReturns.result1
}

func (fake *FakeController) EndCallCount() int {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	return len(fake.endArgsForCall)
}

func (fake *FakeController) EndCalls(stub func() error) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = stub
}

func (fake *FakeController) EndReturns(result1 error) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = nil
	fake.endReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) EndReturnsOnCall(i int, result1 error) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = nil
	if fake.endReturnsOnCall == nil {
		fake.endReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) GetCheckpoints() []*state.State {
	fake.getCheckpointsMutex.Lock()
	ret, specificReturn := fake.getCheckpointsReturnsOnCall[len(fake.getCheckpointsArgsForCall)]
	fake.getCheckpointsArgsForCall = append(fake.getCheckpointsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetCheckpoints", []interface{}{})
	fake.getCheckpointsMutex.Unlock()
	if fake.GetCheckpointsStub != nil {
		return fake.GetCheckpointsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getCheckpointsReturns
	return fakeReturns.result1
}

func (fake *FakeController) GetCheckpointsCallCount() int {
	fake.getCheckpointsMutex.RLock()
	defer fake.getCheckpointsMutex.RUnlock()
	return len(fake.getCheckpointsArgsForCall)
}

func (fake *FakeController) GetCheckpointsCalls(stub func() []*state.State) {
	fake.getCheckpointsMutex.Lock()
	defer fake.getCheckpointsMutex.Unlock()
	fake.GetCheckpointsStub = stub
}

func (fake *FakeController) GetCheckpointsReturns(result1 []*state.State) {
	fake.getCheckpointsMutex.Lock()
	defer fake.getCheckpointsMutex.Unlock()
	fake.GetCheckpointsStub = nil
	fake.getCheckpointsReturns = struct {
		result1 []*state.State
	}{result1}
}

func (fake *FakeController) GetCheckpointsReturnsOnCall(i int, result1 []*state.State) {
	fake.getCheckpointsMutex.Lock()
	defer fake.getCheckpointsMutex.Unlock()
	fake.GetCheckpointsStub = nil
	if fake.getCheckpointsReturnsOnCall == nil {
		fake.getCheckpointsReturnsOnCall = make(map[int]struct {
			result1 []*state.State
		})
	}
	fake.getCheckpointsReturnsOnCall[i] = struct {
		result1 []*state.State
	}{result1}
}

func (fake *FakeController) GetInitialCheckpoint() (*state.State, error) {
	fake.getInitialCheckpointMutex.Lock()
	ret, specificReturn := fake.getInitialCheckpointReturnsOnCall[len(fake.getInitialCheckpointArgsForCall)]
	fake.getInitialCheckpointArgsForCall = append(fake.getInitialCheckpointArgsForCall, struct {
	}{})
	fake.recordInvocation("GetInitialCheckpoint", []interface{}{})
	fake.getInitialCheckpointMutex.Unlock()
	if fake.GetInitialCheckpointStub != nil {
		return fake.GetInitialCheckpointStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInitialCheckpointReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) GetInitialCheckpointCallCount() int {
	fake.getInitialCheckpointMutex.RLock()
	defer fake.getInitialCheckpointMutex.RUnlock()
	return len(fake.getInitialCheckpointArgsForCall)
}

func (fake *FakeController) GetInitialCheckpointCalls(stub func() (*state.State, error)) {
	fake.getInitialCheckpointMutex.Lock()
	defer fake.getInitialCheckpointMutex.Unlock()
	fake.GetInitialCheckpointStub = stub
}

func (fake *FakeController) GetInitialCheckpointReturns(result1 *state.State, result2 error) {
	fake.getInitialCheckpointMutex.Lock()
	defer fake.getInitialCheckpointMutex.Unlock()
	fake.GetInitialCheckpointStub = nil
	fake.getInitialCheckpointReturns = struct {
		result1 *state.State
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetInitialCheckpointReturnsOnCall(i int, result1 *state.State, result2 error) {
	fake.getInitialCheckpointMutex.Lock()
	defer fake.getInitialCheckpointMutex.Unlock()
	fake.GetInitialCheckpointStub = nil
	if fake.getInitialCheckpointReturnsOnCall == nil {
		fake.getInitialCheckpointReturnsOnCall = make(map[int]struct {
			result1 *state.State
			result2 error
		})
	}
	fake.getInitialCheckpointReturnsOnCall[i] = struct {
		result1 *state.State
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetState() (*state.State, error) {
	fake.getStateMutex.Lock()
	ret, specificReturn := fake.getStateReturnsOnCall[len(fake.getStateArgsForCall)]
	fake.getStateArgsForCall = append(fake.getStateArgsForCall, struct {
	}{})
	fake.recordInvocation("GetState", []interface{}{})
	fake.getStateMutex.Unlock()
	if fake.GetStateStub != nil {
		return fake.GetStateStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getStateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) GetStateCallCount() int {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return len(fake.getStateArgsForCall)
}

func (fake *FakeController) GetStateCalls(stub func() (*state.State, error)) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = stub
}

func (fake *FakeController) GetStateReturns(result1 *state.State, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	fake.getStateReturns = struct {
		result1 *state.State
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetStateReturnsOnCall(i int, result1 *state.State, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	if fake.getStateReturnsOnCall == nil {
		fake.getStateReturnsOnCall = make(map[int]struct {
			result1 *state.State
			result2 error
		})
	}
	fake.getStateReturnsOnCall[i] = struct {
		result1 *state.State
		result2 error
	}{result1, result2}
}

func (fake *FakeController) PauseAtSignal(arg1 syscall.Signal) {
	fake.pauseAtSignalMutex.Lock()
	fake.pauseAtSignalArgsForCall = append(fake.pauseAtSignalArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("PauseAtSignal", []interface{}{arg1})
	fake.pauseAtSignalMutex.Unlock()
	if fake.PauseAtSignalStub != nil {
		fake.PauseAtSignalStub(arg1)
	}
}

func (fake *FakeController) PauseAtSignalCallCount() int {
	fake.pauseAtSignalMutex.RLock()
	defer fake.pauseAtSignalMutex.RUnlock()
	return len(fake.pauseAtSignalArgsForCall)
}

func (fake *FakeController) PauseAtSignalCalls(stub func(syscall.Signal)) {
	fake.pauseAtSignalMutex.Lock()
	defer fake.pauseAtSignalMutex.Unlock()
	fake.PauseAtSignalStub = stub
}

func (fake *FakeController) PauseAtSignalArgsForCall(i int) syscall.Signal {
	fake.pauseAtSignalMutex.RLock()
	defer fake.pauseAtSignalMutex.RUnlock()
	argsForCall := fake.pauseAtSignalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) Restore() error {
	fake.restoreMutex.Lock()
	ret, specificReturn := fake.restoreReturnsOnCall[len(fake.restoreArgsForCall)]
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct {
	}{})
	fake.recordInvocation("Restore", []interface{}{})
	fake.restoreMutex.Unlock()
	if fake.RestoreStub != nil {
		return fake.RestoreStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.restoreReturns
	return fakeReturns.result1
}

func (fake *FakeController) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeController) RestoreCalls(stub func() error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = stub
}

func (fake *FakeController) RestoreReturns(result1 error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	fake.restoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) RestoreReturnsOnCall(i int, result1 error) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	if fake.restoreReturnsOnCall == nil {
		fake.restoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendFunction(arg1 string) error {
	fake.sendFunctionMutex.Lock()
	ret, specificReturn := fake.sendFunctionReturnsOnCall[len(fake.sendFunctionArgsForCall)]
	fake.sendFunctionArgsForCall = append(fake.sendFunctionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SendFunction", []interface{}{arg1})
	fake.sendFunctionMutex.Unlock()
	if fake.SendFunctionStub != nil {
		return fake.SendFunctionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendFunctionReturns
	return fakeReturns.result1
}

func (fake *FakeController) SendFunctionCallCount() int {
	fake.sendFunctionMutex.RLock()
	defer fake.sendFunctionMutex.RUnlock()
	return len(fake.sendFunctionArgsForCall)
}

func (fake *FakeController) SendFunctionCalls(stub func(string) error) {
	fake.sendFunctionMutex.Lock()
	defer fake.sendFunctionMutex.Unlock()
	fake.SendFunctionStub = stub
}

func (fake *FakeController) SendFunctionArgsForCall(i int) string {
	fake.sendFunctionMutex.RLock()
	defer fake.sendFunctionMutex.RUnlock()
	argsForCall := fake.sendFunctionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SendFunctionReturns(result1 error) {
	fake.sendFunctionMutex.Lock()
	defer fake.sendFunctionMutex.Unlock()
	fake.SendFunctionStub = nil
	fake.sendFunctionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendFunctionReturnsOnCall(i int, result1 error) {
	fake.sendFunctionMutex.Lock()
	defer fake.sendFunctionMutex.Unlock()
	fake.SendFunctionStub = nil
	if fake.sendFunctionReturnsOnCall == nil {
		fake.sendFunctionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendFunctionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendMessage(arg1 string, arg2 interface{}) error {
	fake.sendMessageMutex.Lock()
	ret, specificReturn := fake.sendMessageReturnsOnCall[len(fake.sendMessageArgsForCall)]
	fake.sendMessageArgsForCall = append(fake.sendMessageArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("SendMessage", []interface{}{arg1, arg2})
	fake.sendMessageMutex.Unlock()
	if fake.SendMessageStub != nil {
		return fake.SendMessageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendMessageReturns
	return fakeReturns.result1
}

func (fake *FakeController) SendMessageCallCount() int {
	fake.sendMessageMutex.RLock()
	defer fake.sendMessageMutex.RUnlock()
	return len(fake.sendMessageArgsForCall)
}

func (fake *FakeController) SendMessageCalls(stub func(string, interface{}) error) {
	fake.sendMessageMutex.Lock()
	defer fake.sendMessageMutex.Unlock()
	fake.SendMessageStub = stub
}

func (fake *FakeController) SendMessageArgsForCall(i int) (string, interface{}) {
	fake.sendMessageMutex.RLock()
	defer fake.sendMessageMutex.RUnlock()
	argsForCall := fake.sendMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) SendMessageReturns(result1 error) {
	fake.sendMessageMutex.Lock()
	defer fake.sendMessageMutex.Unlock()
	fake.SendMessageStub = nil
	fake.sendMessageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendMessageReturnsOnCall(i int, result1 error) {
	fake.sendMessageMutex.Lock()
	defer fake.sendMessageMutex.Unlock()
	fake.SendMessageStub = nil
	if fake.sendMessageReturnsOnCall == nil {
		fake.sendMessageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendMessageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendRequest(arg1 interface{}) (interface{}, error) {
	fake.sendRequestMutex.Lock()
	ret, specificReturn := fake.sendRequestReturnsOnCall[len(fake.sendRequestArgsForCall)]
	fake.sendRequestArgsForCall = append(fake.sendRequestArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("SendRequest", []interface{}{arg1})
	fake.sendRequestMutex.Unlock()
	if fake.SendRequestStub != nil {
		return fake.SendRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.sendRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) SendRequestCallCount() int {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	return len(fake.sendRequestArgsForCall)
}

func (fake *FakeController) SendRequestCalls(stub func(interface{}) (interface{}, error)) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = stub
}

func (fake *FakeController) SendRequestArgsForCall(i int) interface{} {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	argsForCall := fake.sendRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SendRequestReturns(result1 interface{}, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	fake.sendRequestReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeController) SendRequestReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	if fake.sendRequestReturnsOnCall == nil {
		fake.sendRequestReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.sendRequestReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeController) SendSignal(arg1 syscall.Signal) error {
	fake.sendSignalMutex.Lock()
	ret, specificReturn := fake.sendSignalReturnsOnCall[len(fake.sendSignalArgsForCall)]
	fake.sendSignalArgsForCall = append(fake.sendSignalArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("SendSignal", []interface{}{arg1})
	fake.sendSignalMutex.Unlock()
	if fake.SendSignalStub != nil {
		return fake.SendSignalStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendSignalReturns
	return fakeReturns.result1
}

func (fake *FakeController) SendSignalCallCount() int {
	fake.sendSignalMutex.RLock()
	defer fake.sendSignalMutex.RUnlock()
	return len(fake.sendSignalArgsForCall)
}

func (fake *FakeController) SendSignalCalls(stub func(syscall.Signal) error) {
	fake.sendSignalMutex.Lock()
	defer fake.sendSignalMutex.Unlock()
	fake.SendSignalStub = stub
}

func (fake *FakeController) SendSignalArgsForCall(i int) syscall.Signal {
	fake.sendSignalMutex.RLock()
	defer fake.sendSignalMutex.RUnlock()
	argsForCall := fake.sendSignalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SendSignalReturns(result1 error) {
	fake.sendSignalMutex.Lock()
	defer fake.sendSignalMutex.Unlock()
	fake.SendSignalStub = nil
	fake.sendSignalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendSignalReturnsOnCall(i int, result1 error) {
	fake.sendSignalMutex.Lock()
	defer fake.sendSignalMutex.Unlock()
	fake.SendSignalStub = nil
	if fake.sendSignalReturnsOnCall == nil {
		fake.sendSignalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendSignalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendSignalCont(arg1 syscall.Signal) error {
	fake.sendSignalContMutex.Lock()
	ret, specificReturn := fake.sendSignalContReturnsOnCall[len(fake.sendSignalContArgsForCall)]
	fake.sendSignalContArgsForCall = append(fake.sendSignalContArgsForCall, struct {
		arg1 syscall.Signal
	}{arg1})
	fake.recordInvocation("SendSignalCont", []interface{}{arg1})
	fake.sendSignalContMutex.Unlock()
	if fake.SendSignalContStub != nil {
		return fake.SendSignalContStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendSignalContReturns
	return fakeReturns.result1
}

func (fake *FakeController) SendSignalContCallCount() int {
	fake.sendSignalContMutex.RLock()
	defer fake.sendSignalContMutex.RUnlock()
	return len(fake.sendSignalContArgsForCall)
}

func (fake *FakeController) SendSignalContCalls(stub func(syscall.Signal) error) {
	fake.sendSignalContMutex.Lock()
	defer fake.sendSignalContMutex.Unlock()
	fake.SendSignalContStub = stub
}

func (fake *FakeController) SendSignalContArgsForCall(i int) syscall.Signal {
	fake.sendSignalContMutex.RLock()
	defer fake.sendSignalContMutex.RUnlock()
	argsForCall := fake.sendSignalContArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SendSignalContReturns(result1 error) {
	fake.sendSignalContMutex.Lock()
	defer fake.sendSignalContMutex.Unlock()
	fake.SendSignalContStub = nil
	fake.sendSignalContReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SendSignalContReturnsOnCall(i int, result1 error) {
	fake.sendSignalContMutex.Lock()
	defer fake.sendSignalContMutex.Unlock()
	fake.SendSignalContStub = nil
	if fake.sendSignalContReturnsOnCall == nil {
		fake.sendSignalContReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendSignalContReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SetPid(arg1 int) {
	fake.setPidMutex.Lock()
	fake.setPidArgsForCall = append(fake.setPidArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("SetPid", []interface{}{arg1})
	fake.setPidMutex.Unlock()
	if fake.SetPidStub != nil {
		fake.SetPidStub(arg1)
	}
}

func (fake *FakeController) SetPidCallCount() int {
	fake.setPidMutex.RLock()
	defer fake.setPidMutex.RUnlock()
	return len(fake.setPidArgsForCall)
}

func (fake *FakeController) SetPidCalls(stub func(int)) {
	fake.setPidMutex.Lock()
	defer fake.setPidMutex.Unlock()
	fake.SetPidStub = stub
}

func (fake *FakeController) SetPidArgsForCall(i int) int {
	fake.setPidMutex.RLock()
	defer fake.setPidMutex.RUnlock()
	argsForCall := fake.setPidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SetRegs(arg1 *state.State) error {
	fake.setRegsMutex.Lock()
	ret, specificReturn := fake.setRegsReturnsOnCall[len(fake.setRegsArgsForCall)]
	fake.setRegsArgsForCall = append(fake.setRegsArgsForCall, struct {
		arg1 *state.State
	}{arg1})
	fake.recordInvocation("SetRegs", []interface{}{arg1})
	fake.setRegsMutex.Unlock()
	if fake.SetRegsStub != nil {
		return fake.SetRegsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setRegsReturns
	return fakeReturns.result1
}

func (fake *FakeController) SetRegsCallCount() int {
	fake.setRegsMutex.RLock()
	defer fake.setRegsMutex.RUnlock()
	return len(fake.setRegsArgsForCall)
}

func (fake *FakeController) SetRegsCalls(stub func(*state.State) error) {
	fake.setRegsMutex.Lock()
	defer fake.setRegsMutex.Unlock()
	fake.SetRegsStub = stub
}

func (fake *FakeController) SetRegsArgsForCall(i int) *state.State {
	fake.setRegsMutex.RLock()
	defer fake.setRegsMutex.RUnlock()
	argsForCall := fake.setRegsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SetRegsReturns(result1 error) {
	fake.setRegsMutex.Lock()
	defer fake.setRegsMutex.Unlock()
	fake.SetRegsStub = nil
	fake.setRegsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SetRegsReturnsOnCall(i int, result1 error) {
	fake.setRegsMutex.Lock()
	defer fake.setRegsMutex.Unlock()
	fake.SetRegsStub = nil
	if fake.setRegsReturnsOnCall == nil {
		fake.setRegsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setRegsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SetStreams(arg1 *io.PipeWriter, arg2 *io.PipeReader, arg3 *io.PipeReader) {
	fake.setStreamsMutex.Lock()
	fake.setStreamsArgsForCall = append(fake.setStreamsArgsForCall, struct {
		arg1 *io.PipeWriter
		arg2 *io.PipeReader
		arg3 *io.PipeReader
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetStreams", []interface{}{arg1, arg2, arg3})
	fake.setStreamsMutex.Unlock()
	if fake.SetStreamsStub != nil {
		fake.SetStreamsStub(arg1, arg2, arg3)
	}
}

func (fake *FakeController) SetStreamsCallCount() int {
	fake.setStreamsMutex.RLock()
	defer fake.setStreamsMutex.RUnlock()
	return len(fake.setStreamsArgsForCall)
}

func (fake *FakeController) SetStreamsCalls(stub func(*io.PipeWriter, *io.PipeReader, *io.PipeReader)) {
	fake.setStreamsMutex.Lock()
	defer fake.setStreamsMutex.Unlock()
	fake.SetStreamsStub = stub
}

func (fake *FakeController) SetStreamsArgsForCall(i int) (*io.PipeWriter, *io.PipeReader, *io.PipeReader) {
	fake.setStreamsMutex.RLock()
	defer fake.setStreamsMutex.RUnlock()
	argsForCall := fake.setStreamsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeController) Stop() error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
	}{})
	fake.recordInvocation("Stop", []interface{}{})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		return fake.StopStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stopReturns
	return fakeReturns.result1
}

func (fake *FakeController) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeController) StopCalls(stub func() error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeController) StopReturns(result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) StopReturnsOnCall(i int, result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) TakeCheckpoint() error {
	fake.takeCheckpointMutex.Lock()
	ret, specificReturn := fake.takeCheckpointReturnsOnCall[len(fake.takeCheckpointArgsForCall)]
	fake.takeCheckpointArgsForCall = append(fake.takeCheckpointArgsForCall, struct {
	}{})
	fake.recordInvocation("TakeCheckpoint", []interface{}{})
	fake.takeCheckpointMutex.Unlock()
	if fake.TakeCheckpointStub != nil {
		return fake.TakeCheckpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.takeCheckpointReturns
	return fakeReturns.result1
}

func (fake *FakeController) TakeCheckpointCallCount() int {
	fake.takeCheckpointMutex.RLock()
	defer fake.takeCheckpointMutex.RUnlock()
	return len(fake.takeCheckpointArgsForCall)
}

func (fake *FakeController) TakeCheckpointCalls(stub func() error) {
	fake.takeCheckpointMutex.Lock()
	defer fake.takeCheckpointMutex.Unlock()
	fake.TakeCheckpointStub = stub
}

func (fake *FakeController) TakeCheckpointReturns(result1 error) {
	fake.takeCheckpointMutex.Lock()
	defer fake.takeCheckpointMutex.Unlock()
	fake.TakeCheckpointStub = nil
	fake.takeCheckpointReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) TakeCheckpointReturnsOnCall(i int, result1 error) {
	fake.takeCheckpointMutex.Lock()
	defer fake.takeCheckpointMutex.Unlock()
	fake.TakeCheckpointStub = nil
	if fake.takeCheckpointReturnsOnCall == nil {
		fake.takeCheckpointReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.takeCheckpointReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) WithSyscallTrace(arg1 io.Writer) {
	fake.withSyscallTraceMutex.Lock()
	fake.withSyscallTraceArgsForCall = append(fake.withSyscallTraceArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.recordInvocation("WithSyscallTrace", []interface{}{arg1})
	fake.withSyscallTraceMutex.Unlock()
	if fake.WithSyscallTraceStub != nil {
		fake.WithSyscallTraceStub(arg1)
	}
}

func (fake *FakeController) WithSyscallTraceCallCount() int {
	fake.withSyscallTraceMutex.RLock()
	defer fake.withSyscallTraceMutex.RUnlock()
	return len(fake.withSyscallTraceArgsForCall)
}

func (fake *FakeController) WithSyscallTraceCalls(stub func(io.Writer)) {
	fake.withSyscallTraceMutex.Lock()
	defer fake.withSyscallTraceMutex.Unlock()
	fake.WithSyscallTraceStub = stub
}

func (fake *FakeController) WithSyscallTraceArgsForCall(i int) io.Writer {
	fake.withSyscallTraceMutex.RLock()
	defer fake.withSyscallTraceMutex.RUnlock()
	argsForCall := fake.withSyscallTraceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activateMutex.RLock()
	defer fake.activateMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.awaitMessageMutex.RLock()
	defer fake.awaitMessageMutex.RUnlock()
	fake.awaitSignalMutex.RLock()
	defer fake.awaitSignalMutex.RUnlock()
	fake.clearMemRefsMutex.RLock()
	defer fake.clearMemRefsMutex.RUnlock()
	fake.continueMutex.RLock()
	defer fake.continueMutex.RUnlock()
	fake.continueTidMutex.RLock()
	defer fake.continueTidMutex.RUnlock()
	fake.continueWithMutex.RLock()
	defer fake.continueWithMutex.RUnlock()
	fake.detachMutex.RLock()
	defer fake.detachMutex.RUnlock()
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	fake.getCheckpointsMutex.RLock()
	defer fake.getCheckpointsMutex.RUnlock()
	fake.getInitialCheckpointMutex.RLock()
	defer fake.getInitialCheckpointMutex.RUnlock()
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	fake.pauseAtSignalMutex.RLock()
	defer fake.pauseAtSignalMutex.RUnlock()
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	fake.sendFunctionMutex.RLock()
	defer fake.sendFunctionMutex.RUnlock()
	fake.sendMessageMutex.RLock()
	defer fake.sendMessageMutex.RUnlock()
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	fake.sendSignalMutex.RLock()
	defer fake.sendSignalMutex.RUnlock()
	fake.sendSignalContMutex.RLock()
	defer fake.sendSignalContMutex.RUnlock()
	fake.setPidMutex.RLock()
	defer fake.setPidMutex.RUnlock()
	fake.setRegsMutex.RLock()
	defer fake.setRegsMutex.RUnlock()
	fake.setStreamsMutex.RLock()
	defer fake.setStreamsMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.takeCheckpointMutex.RLock()
	defer fake.takeCheckpointMutex.RUnlock()
	fake.withSyscallTraceMutex.RLock()
	defer fake.withSyscallTraceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeController) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ controller.Controller = new(FakeController)
